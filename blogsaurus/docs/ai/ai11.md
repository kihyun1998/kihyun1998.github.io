---
sidebar_position: 11
---

# 🎧 Whitepaper Companion Podcast 요약: Prompt Engineering for Kaggle

## 📑 목차
1. [소개 및 목표](#소개-및-목표)
2. [출력 제어: 토큰 길이와 샘플링](#출력-제어-토큰-길이와-샘플링)
3. [샘플링 기법 상세 설명](#샘플링-기법-상세-설명)
4. [Prompt Engineering 기법](#prompt-engineering-기법)
5. [고급 추론 기법](#고급-추론-기법)
6. [코드 프롬프트 활용](#코드-프롬프트-활용)
7. [멀티모달 프롬프트](#멀티모달-프롬프트)
8. [베스트 프랙티스](#베스트-프랙티스)
9. [마무리 및 제언](#마무리-및-제언)

---

## 소개 및 목표

- **Prompt Engineering**은 LLM이 원하는 작업을 정확히 수행하게 만드는 기술.
- Kaggle 사용자들에게 유용한 **실전 중심 기술** 제공이 목표.
- 예시, 코드, 시스템 메시지 등을 통해 모델의 출력을 정밀하게 조정하는 방법들을 설명.

---

## 출력 제어: 토큰 길이와 샘플링

- **출력 길이(token limit)**는 비용, 처리 시간, Kaggle 제한에 직접 영향을 미침.
- 짧은 출력이 필요하면 **프롬프트 자체를 간결하게 설계**해야 효과적.

---

## 샘플링 기법 상세 설명

| 파라미터 | 설명 | 사용 예 |
|----------|------|---------|
| **Temperature** | 무작위성 조절. 낮을수록 예측 가능하고 정확. | `0.0`: 정확한 코드, `0.9`: 창의적 아이디어 |
| **Top-k** | 상위 k개 단어 중 선택 | `1`: 결정적, `30~40`: 다양성 ↑ |
| **Top-p** | 확률 누적으로 상위 p까지의 단어 제한 (nucleus sampling) | `0.9~0.99`: 균형적 출력 |
| **조합 사용 순서** | 1. Top-k & Top-p → 2. Temperature로 최종 선택 | |

- **Repetition Loop Bug**: 너무 낮거나 높은 temperature에서 **출력 반복 오류 발생 가능**.

---

## Prompt Engineering 기법

### 1. **Zero-shot Prompting**
- 설명만 제공, 예시 없이 수행.
- 간단한 태스크나 코드 조각 요청 시 사용.

### 2. **Few-shot / One-shot Prompting**
- 입력-출력 예시 제공으로 정확한 형식 및 스타일 유도.
- Kaggle 제출 형식(JSON 등)에 매우 유용.
- **예시 품질이 결과에 큰 영향을 미침** → 엣지케이스 포함 권장.

### 3. **System Prompting**
- 모델의 전반적인 역할, 출력 포맷 명시.
- 예: “모든 출력을 JSON으로 생성하라.”

### 4. **Role Prompting**
- 모델에게 특정 인물 역할을 부여.
- 예: “시니어 엔지니어처럼 설명하라.”

### 5. **Contextual Prompting**
- 구체적인 배경정보 제공 (코드, 에러 메시지 등).
- 예: 디버깅 시 사용.

### 6. **Step-back Prompting**
- 직접적인 질문 전, 일반 개념을 먼저 질문 → 더 나은 사고 유도.
- 예: "좋은 피처란 무엇인가?" → "내 데이터셋에 맞는 피처 아이디어는?"

---

## 고급 추론 기법

### 1. **Chain-of-Thought (CoT)**
- 문제 해결 과정을 단계별로 설명하도록 유도.
- **복잡한 논리적 문제 해결에 유리**, 예: 수학 문제, 디버깅.

### 2. **Self-Consistency**
- 여러 번 reasoning path 생성 → 가장 일관된 답 선택.
- **정답 신뢰도 상승** (다소 계산량 증가).

### 3. **Tree of Thoughts (ToT)**
- CoT 확장형. 여러 경로를 **동시에 탐색**하고 **백트래킹**도 수행.
- 창의적 문제 해결에 유리. 예: 다양한 접근이 필요한 Kaggle 문제.

### 4. **ReAct (Reason + Act)**
- 추론과 행동을 결합. 외부 툴(API, 코드 등)과 **연동 가능**.
- 예: 코드 실행 → 결과 분석 → 다음 명령 결정.

### 5. **Automatic Prompt Engineering (APE)**
- 모델이 스스로 다양한 프롬프트를 생성 → 그 성능을 평가하여 최적화.
- 프롬프트 실험 시간 절약 가능.

---

## 코드 프롬프트 활용

### 1. **코드 생성**
- 특정 작업 설명 → 코드 생성. 항상 검토 및 테스트 필요.

### 2. **코드 설명**
- 코드 블록을 넣고 “이 코드가 무슨 역할을 하는지 설명해줘.”

### 3. **코드 번역**
- 언어 간 번역 (예: Bash → Python)

### 4. **디버깅**
- 에러 메시지 + 코드 제공 → 원인 분석 및 수정안 제시
- 최적화 제안도 받을 수 있음

---

## 멀티모달 프롬프트

- 텍스트 외에도 **이미지, 오디오** 등을 입력으로 사용 가능.
- 현재 발전 중이며 Kaggle의 멀티모달 컴페티션에 활용 가능성 ↑

---

## 베스트 프랙티스

| 항목 | 설명 |
|------|------|
| 예시 제공 | One-shot / Few-shot 적극 활용 |
| 명확성 | 프롬프트는 간결하고 직관적으로 |
| 출력 명시 | 원하는 포맷(JSON 등)을 명확히 지시 |
| 긍정적 명령 | “이걸 쓰지 마”보다 “이것만 사용”이 효과적 |
| Max token 제한 | 비용과 출력 길이 제어 |
| 변수 사용 | 프롬프트 템플릿화로 재사용 가능 |
| 다양한 입력 실험 | 질문, 명령, 설명 등 형태 다양화 |
| 클래스 순서 섞기 | 분류 태스크에서는 클래스 편향 방지 |
| 출력 포맷 실험 | CSV, JSON, 스키마 등 구조화된 결과 유도 |
| JSON Repair | 오류 있는 JSON도 복구 가능 |
| 협업 | 프롬프트 전략 공유 및 토론 권장 |
| 문서화 | 모든 시도와 결과 기록 → 재현성 확보 |

---

## 마무리 및 제언

- Prompt Engineering은 **진화 중인 기술**이며, Kaggle 사용자에게는 **강력한 도구**.
- 다양한 기법과 최적의 조합을 **실험하고 문서화**하는 것이 핵심.
- 향후 LLM이 발전함에 따라 **프롬프트 전략 또한 발전**할 것.
