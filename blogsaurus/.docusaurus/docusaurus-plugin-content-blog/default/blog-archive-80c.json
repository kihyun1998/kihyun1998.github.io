{
  "blogPosts": [
    {
      "id": "flutter-til-25",
      "metadata": {
        "permalink": "/blog/flutter-til-25",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-31-til25/index.md",
        "source": "@site/blog/2024-01-31-til25/index.md",
        "title": "Flutter TIL - 25",
        "description": "---",
        "date": "2024-01-31T00:00:00.000Z",
        "formattedDate": "January 31, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "navigator",
            "permalink": "/blog/tags/navigator"
          },
          {
            "label": "named push",
            "permalink": "/blog/tags/named-push"
          },
          {
            "label": "라우팅",
            "permalink": "/blog/tags/라우팅"
          },
          {
            "label": "애니메이션",
            "permalink": "/blog/tags/애니메이션"
          }
        ],
        "readingTime": 6.82,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-25",
          "title": "Flutter TIL - 25",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "navigator",
            "named push",
            "라우팅",
            "애니메이션"
          ]
        },
        "nextItem": {
          "title": "Flutter TIL - 24",
          "permalink": "/blog/flutter-til-24"
        }
      },
      "content": "---\r\n\r\n## Navigator\r\n---\r\n\r\n플러터에서 창 전환하는 방법은 여러 가지가 있다.\r\n\r\n나는 Navigator.pushNamed가 좋다.\r\n\r\n방법은 간단하다. onGenerateRoute 함수를 만들어서 어떤 이름이 들어왔을 때 어떤 페이지로 라우팅 해줄지 정하면 된다.\r\n\r\n```dart\r\n  static const String main = 'main';\r\n  static const String login = 'login';\r\n\r\n  static Route<dynamic>? onGenerateRoute(RouteSettings settings) {\r\n    late final Widget page;\r\n    switch (settings.name) {\r\n      case RoutePath.login:\r\n        page = const LoginPage();\r\n        break;\r\n      case RoutePath.main:\r\n        page = const MainPage();\r\n        break;\r\n    }\r\n\r\n     return MaterialPageRoute(builder: (context) => page);\r\n  }\r\n```\r\n\r\n간단하게 이런식이다. 페이지 이름들을 정의하고 switch case를 사용하여 `=> page` 이런식으로 라우팅을 한다.\r\n\r\nmain.dart에서 MaterialApp안에 아래와 같이 작성만 하면된다.\r\n\r\n```dart\r\n      // 초기 페이지 설정\r\n      initialRoute: RoutePath.login,\r\n      // onGenerateRoute 설정\r\n      onGenerateRoute: RoutePath.onGenerateRoute,\r\n```\r\n\r\n\r\n### 페이드 아웃 방식\r\n\r\n```dart\r\nreturn PageRouteBuilder(\r\n  pageBuilder: (context, animation, secondaryAnimation) => page,\r\n  transitionsBuilder: (context, animation, secondaryAnimation, child) {\r\n    return FadeTransition(\r\n      opacity: animation,\r\n      child: child,\r\n    );\r\n  },\r\n  transitionDuration: const Duration(seconds: 1),\r\n);\r\n```\r\n\r\n페이드 아웃을 하려면 FadeTransition을 사용할 수 있다.\r\n\r\n그리고 `transitionDuration` 속성을 사용해서 페이드 아웃 시간도 정할 수 있다.\r\n\r\n### 슬라이드 방식\r\n\r\n```dart\r\n  return PageRouteBuilder(\r\n    pageBuilder: (context, animation, secondaryAnimation) => page,\r\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\r\n      const begin = Offset(10.0, 0.0);\r\n      const end = Offset.zero;\r\n      const curve = Curves.ease;\r\n      final tween =\r\n          Tween(begin: begin, end: end).chain(CurveTween(curve: curve));\r\n      final offsetAnimation = animation.drive(tween);\r\n      return SlideTransition(\r\n        position: offsetAnimation,\r\n        child: child,\r\n      );\r\n    },\r\n    transitionDuration: const Duration(milliseconds: 500),\r\n  );\r\n```\r\n\r\n이건 슬라이드 방식이다.\r\n\r\nbegin, end에서 사용하는 Offset은 좌표를 나타낸다. bigin의 Offset x좌표 크기가 작으면 움직이는 속도도 작아짐\r\n\r\ncurve 관련해서는 아래 정리한다.\r\n\r\n:::tip curve\r\n`Curves.linear`: 일정한 속도로 애니메이션을 진행합니다.\r\n`Curves.ease`: 처음과 끝은 천천히, 중간은 빠르게 가속하는 가속도 곡선입니다.\r\n`Curves.easeIn`: 처음에 천천히 가속하는 가속도 곡선입니다.\r\n`Curves.easeOut`: 끝에서 천천히 감속하는 감속도 곡선입니다.\r\n`Curves.easeInOut`: 처음과 끝에서 천천히 가속하고 중간에서 천천히 감속하는 곡선입니다.\r\n`Curves.bounceIn`: 바운스 효과가 있는 곡선으로, 처음에 튀어오르는 효과가 있습니다.\r\n`Curves.bounceOut`: 바운스 효과가 있는 곡선으로, 끝에서 튀어오르는 효과가 있습니다.\r\n`Curves.elasticIn`: 탄력 효과가 있는 곡선으로, 처음에 잠깐 튕기는 효과가 있습니다.\r\n`Curves.elasticOut`: 탄력 효과가 있는 곡선으로, 끝에서 잠깐 튕기는 효과가 있습니다.\r\n:::\r\n\r\n그렇게 해서 `SlideTransition`를 사용해서 슬라이드 형식으로 한다. \r\n\r\n`transitionsBuilder`의 `child`값에는 `pageBuilder`에서 return한 page가 들어간다.\r\n\r\n\r\n## 애니메이션\r\n---\r\n\r\n```dart\r\n  void _animateWindowAndNavigate(BuildContext context) {\r\n    const targetSize = Size(800, 800);\r\n    const duration = Duration(milliseconds: 500); // 애니메이션 지속 시간\r\n    const stepDuration = Duration(milliseconds: 10);\r\n    int steps = duration.inMilliseconds ~/ stepDuration.inMilliseconds;\r\n    double widthStep = (targetSize.width - appWindow.size.width) / steps;\r\n    double heightStep = (targetSize.height - appWindow.size.height) / steps;\r\n\r\n    Timer.periodic(stepDuration, (timer) {\r\n    appWindow.size = Size(\r\n      appWindow.size.width + widthStep,\r\n      appWindow.size.height + heightStep,\r\n    );\r\n\r\n      if (appWindow.size.width >= targetSize.width ||\r\n          appWindow.size.height >= targetSize.height) {\r\n        timer.cancel();\r\n        appWindow.size = targetSize;\r\n\r\n        // 창 크기 조정 후 페이지 전환\r\n        Navigator.pushNamed(context, RoutePath.main);\r\n      }\r\n    });\r\n  }\r\n```\r\n\r\n페이지가 변할 때 각 페이지에 맞는 크기를 위해서 처음에 페이지에 도달하면 그냥 바로 변하게 했더니 버벅거리는 것 같아서 사이즈를 키우고 화면 전환하도록 해봤다.\r\n\r\n기존 크기에서 스텝마다 계산된 값(`widthStep`,`heightStep`)을 스텝의 시간(`stepDuration`)마다 키우는 것이다.\r\n\r\n```dart\r\n    Timer.periodic(stepDuration, (timer) {\r\n    appWindow.size = Size(\r\n      appWindow.size.width + widthStep,\r\n      appWindow.size.height + heightStep,\r\n    );\r\n\r\n  ...\r\n  \r\n  })\r\n```\r\n\r\n`Timer.periodic`을 사용해서 `stepDuration` 마다 아래 로직을 수행하면서 if문을 통해 조건이 충족한다면 `timer.cancel` 즉 무한루프를 나오는 듯한 break를 거는 로직ㅇ비니다.\r\n\r\n근데 위는 화면이 커질수록 버벅거린다. 그래서 마지막에 커지는 속도를 줄여야 하나 했다. 아래와 같은 코드가 나왔다.\r\n\r\n\r\n```dart\r\n  void _animateWindowAndNavigate(BuildContext context) {\r\n    const targetSize = Size(800, 800);\r\n    const duration = Duration(milliseconds: 500); // 애니메이션 지속 시간\r\n    const timerDuration = Duration(milliseconds: 10);\r\n    const curve = Curves.decelerate;\r\n    int steps = duration.inMilliseconds ~/ timerDuration.inMilliseconds;\r\n    int currentStep = 0;\r\n\r\n    Timer.periodic(timerDuration, (timer) {\r\n      double fraction = (currentStep / steps);\r\n      // 'Curves.decelerate' 커브를 사용하여 변화율을 계산합니다.\r\n      double easedFraction = curve.transform(fraction);\r\n      double width = appWindow.size.width +\r\n          ((targetSize.width - appWindow.size.width) * easedFraction);\r\n      double height = appWindow.size.height +\r\n          ((targetSize.height - appWindow.size.height) * easedFraction);\r\n\r\n      appWindow.size = Size(width, height);\r\n\r\n      currentStep++;\r\n      if (fraction >= 1) {\r\n        timer.cancel();\r\n        appWindow.size = targetSize; \r\n\r\n        // 창 크기 조정 후 페이지 전환\r\n        Navigator.pushNamed(context, RoutePath.main);\r\n      }\r\n    });\r\n  }\r\n```\r\n\r\n위 코드는 마지막에 속도를 줄여야 하기에 `Curves.decelerate`를 사용해서 커브 값을 얻었고 변화율을 계산하여 적용해봤지만\r\n\r\n그래도 버벅거림은 해결하지 못했습니다.\r\n\r\n\r\n```dart\r\n  static void animateWindowForMain(BuildContext context, String routePath) {\r\n    const targetSize = mainPageSize; // 정의된 main page size\r\n    const duration = Duration(milliseconds: 500); // 애니메이션 지속 시간\r\n    const curve = Curves.easeOutExpo; // 보다 부드러운 애니메이션을 위한 커브\r\n    final numFrames = duration.inMilliseconds ~/ 16; // 약 60fps\r\n\r\n    List<Size> frameSizes = List.generate(numFrames, (index) {\r\n      double progress = (index / numFrames);\r\n      double animatedValue = curve.transform(progress);\r\n      double width = appWindow.size.width +\r\n          ((targetSize.width - appWindow.size.width) * animatedValue);\r\n      double height = appWindow.size.height +\r\n          ((targetSize.height - appWindow.size.height) * animatedValue);\r\n      return Size(width, height);\r\n    });\r\n\r\n    int currentFrame = 0;\r\n    Timer.periodic(const Duration(milliseconds: 16), (timer) {\r\n      Size newSize = frameSizes[currentFrame];\r\n      appWindow.size = newSize;\r\n\r\n      currentFrame++;\r\n      if (currentFrame >= frameSizes.length) {\r\n        timer.cancel();\r\n        appWindow.size = targetSize;\r\n\r\n        // 창 크기 조정 후 페이지 전환\r\n        Navigator.pushNamed(context, routePath);\r\n      }\r\n    });\r\n  }\r\n```\r\n\r\n그래서 `List<Size>` 타입의 변수 안에 미리 크기들을 계산해서 넣어놓고 `Timer.periodic`에선 리스트에 있는 값을 꺼내기만 하면 되니 더욱 깔끔해질 수 있었습니다."
    },
    {
      "id": "flutter-til-24",
      "metadata": {
        "permalink": "/blog/flutter-til-24",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-25-til24/index.md",
        "source": "@site/blog/2024-01-25-til24/index.md",
        "title": "Flutter TIL - 24",
        "description": "---",
        "date": "2024-01-25T00:00:00.000Z",
        "formattedDate": "January 25, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "intl",
            "permalink": "/blog/tags/intl"
          },
          {
            "label": "localization",
            "permalink": "/blog/tags/localization"
          },
          {
            "label": "다국어 설정",
            "permalink": "/blog/tags/다국어-설정"
          }
        ],
        "readingTime": 1.145,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-24",
          "title": "Flutter TIL - 24",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "intl",
            "localization",
            "다국어 설정"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 25",
          "permalink": "/blog/flutter-til-25"
        },
        "nextItem": {
          "title": "Flutter TIL - 23",
          "permalink": "/blog/flutter-til-23"
        }
      },
      "content": "---\r\n\r\n## 다국어 설정\r\n---\r\n\r\n1. `flutter_localization`,`intl` 패키지 추가\r\n\r\n2. vs code `Flutter Intl` extension 설치\r\n\r\n3. pubspec.yaml파일에 아래 내용 입력\r\n```yaml\r\nflutter_intl:\r\n  enabled: true\r\n  arb_dir: lib/util/lang/l10n\r\n  output_dir: lib/util/lang/generated\r\n```\r\n\r\n4. `ctrl`+`shift`+`p`로 명령어 팔레트 열고 flutter intl initialize\r\n\r\n5. 그러면 lib/util/lang 밑에 `l10n`과 `generated`가 생김\r\n\r\n끝\r\n\r\n### 한국어 추가하기\r\n\r\n1. `ctrl`+`shift`+`p`로 열고 intl: Add locale하고 `ko`추가\r\n\r\n2. 그러면 intl_ko.arb파일 생긴다.\r\n\r\n```\r\n{\r\n    \"@@locale\" : \"en\",\r\n    \"language\" : \"language\"\r\n}\r\n\r\n{\r\n    \"@@locale\" : \"ko\",\r\n    \"language\" : \"언어\"\r\n}\r\n```\r\n\r\n이런식으로 설정하면 된다.\r\n\r\n\r\n### 추가 설정\r\n\r\n1. ios에서 사용하려면 `ios/Runner/Info.plist` 파일에서\r\n\r\n```\r\n<key>CFBundleDevelopmentRegion</key>\r\n\t<array>\r\n\t\t<string>en</string>\r\n\t\t<string>ko</string>\r\n\t</array>\r\n```\r\n\r\nkey태그 밑에 array태그 추가하기\r\n\r\n\r\n2. main.dart 설정\r\n\r\n```dart\r\nimport 'package:flutter_localizations/flutter_localizations.dart';\r\n\r\n...\r\n      localizationsDelegates: const [\r\n        S.delegate,\r\n        GlobalMaterialLocalizations.delegate,\r\n        GlobalWidgetsLocalizations.delegate,\r\n        GlobalCupertinoLocalizations.delegate,\r\n      ],\r\n      supportedLocales: S.delegate.supportedLocales,\r\n...\r\n```\r\n\r\n해당 내용 추가하기\r\n\r\n그리고 추가적으로 구현해야할 것이 locale값을 watch하는 provider 만들어서 `MaterialApp` 안에 `locale` 속성값에 `watch`로 넣기"
    },
    {
      "id": "flutter-til-23",
      "metadata": {
        "permalink": "/blog/flutter-til-23",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-24-til23/index.md",
        "source": "@site/blog/2024-01-24-til23/index.md",
        "title": "Flutter TIL - 23",
        "description": "---",
        "date": "2024-01-24T00:00:00.000Z",
        "formattedDate": "January 24, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "TextOverflow",
            "permalink": "/blog/tags/text-overflow"
          }
        ],
        "readingTime": 0.67,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-23",
          "title": "Flutter TIL - 23",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "TextOverflow"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 24",
          "permalink": "/blog/flutter-til-24"
        },
        "nextItem": {
          "title": "Flutter TIL - 22",
          "permalink": "/blog/flutter-til-22"
        }
      },
      "content": "---\r\n\r\n## TextOverflow\r\n---\r\n\r\nText위젯에서 maxLines를 정하고 overflow를 정의할 수 있다.\r\n\r\n### 종류\r\n\r\n- `TextOverflow.clip`: 텍스트가 그 경계를 넘어가면 잘라냅니다. 이는 기본값입니다.\r\n\r\n- `TextOverflow.fade`: 텍스트가 그 경계를 넘어가면 점점 흐려지게 만듭니다.\r\n\r\n- `TextOverflow.ellipsis`: 텍스트가 그 경계를 넘어가면 끝에 '...'를 추가합니다.\r\n\r\n- `TextOverflow.visible`: 텍스트가 그 경계를 넘어가도 잘리거나 사라지지 않고 그대로 보이게 합니다.\r\n\r\nfade나 ellipsis를 많이 쓸 듯"
    },
    {
      "id": "flutter-til-22",
      "metadata": {
        "permalink": "/blog/flutter-til-22",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-23-til22/index.md",
        "source": "@site/blog/2024-01-23-til22/index.md",
        "title": "Flutter TIL - 22",
        "description": "---",
        "date": "2024-01-23T00:00:00.000Z",
        "formattedDate": "January 23, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dll 사용",
            "permalink": "/blog/tags/dll-사용"
          },
          {
            "label": "typedef",
            "permalink": "/blog/tags/typedef"
          }
        ],
        "readingTime": 2.34,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-22",
          "title": "Flutter TIL - 22",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dll 사용",
            "typedef"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 23",
          "permalink": "/blog/flutter-til-23"
        },
        "nextItem": {
          "title": "Flutter TIL - 21",
          "permalink": "/blog/flutter-til-21"
        }
      },
      "content": "---\r\n\r\n## typedef\r\n---\r\n\r\n```dart\r\ntypedef HelloThere = Pointer<Utf8> Function(Pointer<Utf8> str);\r\n```\r\n\r\n`typedef`를 사용하면 특정 타입을 커스텁 할 수 있다.\r\n\r\n단 문제점이 하나 있다. 함수 안에서는 사용못한다. 무조건 함수 밖에서 사용..\r\n\r\n## dll 사용하기\r\n---\r\n\r\ndll 사용하려면 [ffi](https://pub.dev/packages/ffi)라는 패키지를 설치해야한다.\r\n(dart:ffi랑은 다른 패키지다. 이게 있어야 `Pointer<Utf8>`사용 가능)\r\n\r\n### 함수 불러오기\r\n\r\n```dart\r\nfinal DynamicLibrary dylib = DynamicLibrary.open('hello.dll');\r\n```\r\n\r\n위처럼 dll파일 읽어서 일단 dll파일 자체를 DynamicLibrary 타입의 변수에 저장하고\r\n(이 때 `hello.dll`파일 위치는 root다.)\r\n\r\n```dart\r\ntypedef HelloThereFunc = Pointer<Utf8> Function(Pointer<Utf8> str);\r\ntypedef HelloThere = Pointer<Utf8> Function(Pointer<Utf8> str);\r\n```\r\n\r\n편의를 위해서 2개의 함수형을 typedef로 정의합니다.\r\n\r\n`HelloThereFunc`는 C 라이브러리의 native 함수이고\r\n`HelloThere`는 Dart에서 사용하는 함수입니다.\r\n\r\n타입이 `Pointer<Utf8>`인 이유는 Dart와 C의 문자열 나타내는 방법이 달라서 어쩔 수 없다고 하네요\r\n\r\n\r\n```dart\r\nfinal helloThere =\r\n        dylib.lookupFunction<HelloThereFunc, HelloThere>('HelloThere');\r\n```\r\n\r\n이제 실질적으로 dll에 있는 함수를 import하는 방법입니다.\r\n\r\n`dll`파일에 `DynamicLibrary`의 `lookupFunction<C_native_func, Dart_func>`을 사용하여서 `('함수이름')`이 함수를 호출하는 것입니다.\r\n\r\n코드로 보자면\r\n\r\n```dart\r\nfinal 변수명 = dll이름.lookupFunction<C_네이티브함수_시그니처, Dart_함수_시그니처>(호출할 함수이름);\r\n```\r\n\r\n라고 정리할 수 있습니다.\r\n\r\n### 사용법\r\n\r\n```dart\r\nfinal Pointer<Utf8> nName = 'Park'.toNativeUtf8();\r\nfinal Pointer<Utf8> nRst = helloThere(nName);\r\ncalloc.free(nName);\r\n\r\nCenter(\r\n  child: Text(nRst.toDartString()),\r\n),\r\n```\r\n\r\n간단한 사용 예시 입니다.\r\n\r\n먼저 인자값 선언을 합니다(nName). 스트링을 `toNativeUtf8()`로 변환해주고\r\n\r\n함수 호출하고\r\n\r\n다 쓴 값은 free 시켜줍니다.\r\n\r\nnRst도 free시켜줘야하는데 지금 시키면 프로그램이 꺼집니다. 이에 대해서는 조금 더 공부해봐야 합니다."
    },
    {
      "id": "flutter-til-21",
      "metadata": {
        "permalink": "/blog/flutter-til-21",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-22-til21/index.md",
        "source": "@site/blog/2024-01-22-til21/index.md",
        "title": "Flutter TIL - 21",
        "description": "---",
        "date": "2024-01-22T00:00:00.000Z",
        "formattedDate": "January 22, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "window manger",
            "permalink": "/blog/tags/window-manger"
          },
          {
            "label": "bitsdojo_window",
            "permalink": "/blog/tags/bitsdojo-window"
          }
        ],
        "readingTime": 2.3,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-21",
          "title": "Flutter TIL - 21",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "window manger",
            "bitsdojo_window"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 22",
          "permalink": "/blog/flutter-til-22"
        },
        "nextItem": {
          "title": "Flutter TIL - 20",
          "permalink": "/blog/flutter-til-20"
        }
      },
      "content": "---\r\n\r\n## Window app에서 상단바 커스텀\r\n---\r\n\r\n[bitdoho_window](\"https://pub.dev/packages/bitsdojo_window)라는 패키지를 이용한다.\r\n\r\n### 초기값 설정\r\n\r\n```dart\r\nvoid main() {\r\n  runApp(const MyApp());\r\n  doWhenWindowReady(() {\r\n    final win = appWindow; // 정의\r\n    const initialSize = Size(600, 450); // 사이즈 정의\r\n    win.minSize = initialSize; // 최소 사이즈 할당\r\n    win.size = initialSize; // 초기 사이즈 할당\r\n    win.alignment = Alignment.center; // 실행시 화면 위치\r\n    win.title = \"Custom Window app\"; // 창 이름\r\n    win.show(); // 이거 있어야 보여준다.\r\n  });\r\n}\r\n```\r\n\r\n### 테두리 설정\r\n---\r\n\r\n```dart\r\nScaffold(\r\n  // 테두리\r\n  body: WindowBorder(\r\n    color: const Color(0xFF0B4279),\r\n    width: 1,\r\n    child: const Row(\r\n      children: [\r\n        LeftSide(),\r\n        RightSide(),\r\n      ],\r\n    ),\r\n  ),\r\n),\r\n```\r\n\r\n`WindowBorder`라는 위젯을 사용해서 테두리를 설정할 수 있다. 테두리의 두께, 색상을 설정할 수 있다.\r\n\r\n### 이동 설정\r\n\r\n```dart\r\nchild: Column(\r\n  children: [\r\n    WindowTitleBarBox(\r\n      child: Row(\r\n        children: [\r\n          Expanded(\r\n            child: MoveWindow(),\r\n          ),\r\n          const WindowButtons(),\r\n        ],\r\n      ),\r\n    ),\r\n  ],\r\n),\r\n```\r\n\r\n`WindowTitleBarBox`를 정의하고 안에서 MoveWindow를 정의하면 해당 칸을 잡고 드래그하면 창도 드래그하도록 설정할 수 있다.\r\n\r\n### 이벤트 버튼 설정\r\n\r\n```dart\r\nWindowButtonColors buttonColors = WindowButtonColors(\r\n  iconNormal: const Color(0xFF0B4279),\r\n  mouseOver: const Color(0xFF2A78C6),\r\n  mouseDown: const Color(0xFF0B4279),\r\n  iconMouseOver: const Color(0xFF0B4279),\r\n  iconMouseDown: const Color(0xFFCEE1FF),\r\n);\r\n\r\nRow(\r\n  children: [\r\n    MinimizeWindowButton(\r\n      colors: buttonColors,\r\n    ),\r\n    MaximizeWindowButton(\r\n      colors: buttonColors,\r\n    ),\r\n    CloseWindowButton(),\r\n  ],\r\n);\r\n```\r\n\r\n이미 정의 돼있는 이벤트 버튼을 사용할 수 있습니다. 여러 가지 색상 속성을 정의하여 커스텀할 수 있습니다.\r\n\r\n## 플랫폼 별 설정\r\n---\r\n\r\n\r\n### For Windows\r\n\r\n```cpp\r\n#include <bitsdojo_window_windows/bitsdojo_window_plugin.h>\r\nauto bdw = bitsdojo_window_configure(BDW_CUSTOM_FRAME | BDW_HIDE_ON_STARTUP);\r\n```\r\n\r\n위 내용을 `windows\\runner\\main.cpp`의 최상단에 작성해야 합니다.\r\n\r\n### For Mac\r\n\r\n`macos\\runner\\MainFlutterWindow.swift`에서\r\n\r\n```swift\r\nimport bitsdojo_window_macos // FlutterMacOS 밑에 추가\r\n```\r\n\r\n이 코드를 `import FlutterMacOs`밑에 추가하고\r\n\r\n```swift\r\nclass MainFlutterWindow: NSWindow {\r\n\r\n// 를 아래 코드로 변경\r\n\r\nclass MainFlutterWindow: BitsdojoWindow {\r\n```\r\n\r\n```swift\r\noverride func bitsdojo_window_configure() -> UInt {\r\n    return BDW_CUSTOM_FRAME | BDW_HIDE_ON_STARTUP\r\n  }\r\n```\r\n\r\n이 코드를\r\n\r\n```swift\r\noverride func awakeFromNib() {\r\n```\r\n\r\n이 코드 위에 추가합니다.\r\n\r\n리눅스를 위한 방법도 있는데 따로 정리하진 않겠습니다."
    },
    {
      "id": "flutter-til-20",
      "metadata": {
        "permalink": "/blog/flutter-til-20",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-19-til20/index.md",
        "source": "@site/blog/2024-01-19-til20/index.md",
        "title": "Flutter TIL - 20",
        "description": "---",
        "date": "2024-01-19T00:00:00.000Z",
        "formattedDate": "January 19, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "path_provider",
            "permalink": "/blog/tags/path-provider"
          },
          {
            "label": "AsyncValue",
            "permalink": "/blog/tags/async-value"
          }
        ],
        "readingTime": 2.56,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-20",
          "title": "Flutter TIL - 20",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "path_provider",
            "AsyncValue"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 21",
          "permalink": "/blog/flutter-til-21"
        },
        "nextItem": {
          "title": "Flutter TIL - 19",
          "permalink": "/blog/flutter-til-19"
        }
      },
      "content": "---\r\n\r\n## path_provider 종류\r\n---\r\n\r\ngpt의 답변을 정리합니다.\r\n\r\n1. getApplicationDocumentsDirectory()  \r\n  - Windows에서 이 함수는 사용자의 \"Documents\" 폴더에 있는 애플리케이션 데이터 디렉토리를 반환합니다. 보통 `C:\\Users\\<User Name>\\Documents` 경로로 찾을 수 있습니다.\r\n\r\n2. getApplicationSupportDirectory()  \r\n  - `C:\\Users\\User\\AppData\\Roaming\\ [패키지이름]\\ [프로젝트이름]`\r\n\r\n3. getDownloadsDirectory()  \r\n  - 사용자의 \"Downloads\" 폴더를 반환합니다, 보통 `C:\\Users\\<User Name>\\Downloads`에 위치합니다.\r\n\r\n4. getExternalCacheDirectories()  \r\n  - Windows에서 외부 캐시 디렉토리는 일반적으로 해당되지 않습니다. 이 함수는 Windows에서 지원되지 않을 가능성이 높습니다.\r\n\r\n5. getExternalStorageDirectories({StorageDirectory? type})  \r\n  - Windows에서 외부 저장소 디렉토리는 일반적으로 해당되지 않으며, 이 함수는 Android 플랫폼에 특화되어 있습니다.\r\n\r\n6. getExternalStorageDirectory()\r\n  - 이 함수도 마찬가지로 Windows에서는 일반적으로 사용되지 않습니다. Android에서는 외부 저장소의 루트 디렉토리를 반환합니다.\r\n\r\n7. getLibraryDirectory()  \r\n  - macOS에서만 사용되며, Windows에서는 해당 디렉토리가 없습니다.\r\n\r\n8. getTemporaryDirectory()  \r\n  - 시스템의 임시 폴더를 반환합니다. Windows에서는 보통 `C:\\Users\\<User Name>\\AppData\\Local\\Temp`에 위치합니다.\r\n\r\n\r\n## AsyncValeu - properties\r\n---\r\n\r\n### value\r\n\r\n<table>\r\n  <tr class=\"custom_th\">\r\n    <th>Async종류</th>\r\n    <th>previous value [X]</th>\r\n    <th>previous value [O]</th>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncLoading</td>\r\n    <td>null</td>\r\n    <td>previous value</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncData</td>\r\n    <td>current value</td>\r\n    <td>current value</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncError</td>\r\n    <td>rethrow error</td>\r\n    <td>previous value</td>\r\n  </tr>\r\n</table>\r\n\r\n### error, stackTrace\r\n\r\n<table>\r\n  <tr class=\"custom_th\">\r\n    <th>Async종류</th>\r\n    <th>previous error [X]</th>\r\n    <th>previous error [O]</th>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncLoading</td>\r\n    <td>null</td>\r\n    <td>previous error</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncData</td>\r\n    <td>null</td>\r\n    <td>null</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncError</td>\r\n    <td>current error</td>\r\n    <td>current error</td>\r\n  </tr>\r\n</table>\r\n\r\n\r\n### isLoading/hasValue/hasError\r\n\r\n<table class=\"custom_table\">\r\n  <tr class=\"custom_th\">\r\n    <th>Async종류</th>\r\n    <th>previous value [X]<br/>previous error [X]</th>\r\n    <th>previous value [X]<br/>previous error [O]</th>\r\n    <th>previous value [O]<br/>previous error [X]</th>\r\n    <th>previous value [O]<br/>previous error [O]</th>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncLoading</td>\r\n    <td>isLoading [O] <br/>hasValue [X] <br/>hasError [X]</td>\r\n    <td>isLoading [O] <br/>hasValue [O] <br/>hasError [X]</td>\r\n    <td>isLoading [O] <br/>hasValue [X] <br/>hasError [O]</td>\r\n    <td>isLoading [O] <br/>hasValue [O] <br/>hasError [O]</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncData</td>\r\n    <td>isLoading [X] <br/>hasValue [O] <br/>hasError [X]</td>\r\n    <td>isLoading [X] <br/>hasValue [O] <br/>hasError [X]</td>\r\n    <td>isLoading [X] <br/>hasValue [O] <br/>hasError [X]</td>\r\n    <td>isLoading [X] <br/>hasValue [O] <br/>hasError [X]</td>\r\n  </tr>\r\n  <tr>\r\n    <td class=\"custom_td\">AsyncError</td>\r\n    <td>isLoading [X] <br/>hasValue [X] <br/>hasError [O]</td>\r\n    <td>isLoading [X] <br/>hasValue [O] <br/>hasError [O]</td>\r\n    <td>isLoading [X] <br/>hasValue [X] <br/>hasError [O]</td>\r\n    <td>isLoading [X] <br/>hasValue [O] <br/>hasError [O]</td>\r\n  </tr>\r\n</table>"
    },
    {
      "id": "flutter-til-19",
      "metadata": {
        "permalink": "/blog/flutter-til-19",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-18-til19/index.md",
        "source": "@site/blog/2024-01-18-til19/index.md",
        "title": "Flutter TIL - 19",
        "description": "---",
        "date": "2024-01-18T00:00:00.000Z",
        "formattedDate": "January 18, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "notifierProvider",
            "permalink": "/blog/tags/notifier-provider"
          },
          {
            "label": "asyncNotifierProvider",
            "permalink": "/blog/tags/async-notifier-provider"
          },
          {
            "label": "tear-offs",
            "permalink": "/blog/tags/tear-offs"
          },
          {
            "label": "enum based class",
            "permalink": "/blog/tags/enum-based-class"
          },
          {
            "label": "sealed based class",
            "permalink": "/blog/tags/sealed-based-class"
          }
        ],
        "readingTime": 5.84,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-19",
          "title": "Flutter TIL - 19",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "notifierProvider",
            "asyncNotifierProvider",
            "tear-offs",
            "enum based class",
            "sealed based class"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 20",
          "permalink": "/blog/flutter-til-20"
        },
        "nextItem": {
          "title": "Flutter TIL - 18",
          "permalink": "/blog/flutter-til-18"
        }
      },
      "content": "---\r\n\r\n## AutoDispose\r\n---\r\n\r\nautodispose를 사용하려면\r\n\r\n```dart\r\nfinal counterProvider = NotifierProvider.autoDispose<Counter, int>(Counter.new);\r\n```  \r\n\r\n로 선언해야 하고\r\n\r\n```dart\r\nclass Counter extends AutoDisposeNotifier<int>{}\r\n```\r\n\r\n위처럼 Notifier를 사용해야 한다.\r\n\r\n\r\n## Family\r\n---\r\n\r\n```dart\r\nfinal counterProvider = NotifierProvider.family<Counter, int, int>(Counter.new);\r\n```\r\n\r\nfamily를 사용하려면 family와 넘겨줄 인자값을 추가해야하고\r\n\r\n```dart\r\nclass Counter extends FamilyNotifier<int, int> {\r\n  @override\r\n  int build(int arg) {return arg;}\r\n}\r\n```\r\n\r\nNotifier도 FamilyNotifier와 인자 추가와 build함수에 인자를 추가해야 한다.\r\n\r\n\r\n## AutoDispose Family\r\n---\r\n\r\n위의 둘을 합치면 된다.\r\n\r\n## riverpod generator 이용\r\n---\r\n\r\ngenerator를 이용해서 notifier를 만들면 더 쉽다.\r\n\r\n1. riverpodpart 만들기\r\n\r\n2. riverpodclass로 만들기 (riverpodclass가 notifier다.)\r\n\r\n3. 이름 넣고 build 함수 타입 지정하기\r\n\r\n4. 나머지 구현\r\n\r\nAutoDispose는 어노테이션에 따라 결정되고 family 여부는 build함수 인자값 존재 유무로 결정된다고 합니다.\r\n\r\n추가 특이사항이 있으면 그 때 정리해야지.\r\n\r\n\r\n## state shape\r\n---\r\n\r\n2가지 있다고 한다.\r\n\r\n`enum`, `sealed` .. 그렇다\r\n\r\n추가로 `AsyncValue`도 있다.\r\n\r\n\r\n[이곳의 API](https://www.boredapi.com/)를 활용한다.\r\n\r\n\r\n## data model을 freezed로 만드는 절차\r\n---\r\n\r\n1. `ptf`\r\n\r\n2. `pts`\r\n\r\n3. `fdataclass`\r\n\r\n4. factory 생성자에 인자값 넣기 required로 아니여도되구\r\n\r\n5. `fromJson`키워드로 fromJson 만들기 (이름은 class이름붙이고)\r\n\r\n6. 메서드들 만들기(empty,add,remove 등)\r\n\r\n## stat를 freezed로 만드는 절차\r\n---\r\n\r\n1. `ptf`\r\n\r\n2. `fdataclass`\r\n\r\n3. 필요한 factory 메서드 만들기\r\n\r\n\r\n## dio provier 만들기 절차\r\n---\r\n\r\n1. `riverpodpart`\r\n\r\n2. `riverpod`으로 provider만들기\r\n\r\n3. 아래 문법 처럼\r\n\r\n```dart\r\n@riverpod\r\nDio dio(DioRef ref) {\r\n  return Dio(BaseOptions(baseUrl: '[Target URL]'));\r\n}\r\n```\r\n\r\n## Enum based에서 값 요청 provider 만드는 절차\r\n---\r\n\r\n1. `riverpodpart`와  `riverpodclass`로 초기 설정 후 이름 설정\r\n\r\n2. build 함수 타입 정해주고 return 값 정해주기\r\n\r\n3. 여러 상태 컨트롤하는 함수 만들기(loading, error, success 등등)\r\n\r\n4. 흐름을 적자면 먼저 state의 `status를 loading`으로 바꿔주고 `Get요청`을 날린다음에 성공적으로 값을 가져오면 `fromJson`해가지구 `copyWith`해서 `status success와 값을 가져온 값으로 변경`을 한다. 에러가 난다면 `copyWith해서 status failure와 error에 e.toString` 넣어줌\r\n\r\n### 특이점 정리\r\n\r\n- copyWith로 값 변경  \r\n- single state class임\r\n\r\n## inistate modifier 주의할 점\r\n\r\n페이지에 진입했을 때 바로 api를 쏘는 동작을 하고 싶어서 initState에 api 통신하는 코드를 넣었다. 이 때 UI를 수정하는 동작도 포함돼있어서\r\n\r\n`FlutterError (Tried to modify a provider while the widget tree was building....` 에러가 났다. \r\n\r\n```dart\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    ref.read(enumActivityProvider.notifier).fetchActivity(activityTypes[0]);\r\n  }\r\n\r\n// 이거를 아래로 수정\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    Future.delayed(Duration.zero, () {\r\n      ref.read(enumActivityProvider.notifier).fetchActivity(activityTypes[0]);\r\n    });\r\n  }\r\n```\r\n\r\n`Future.delayed`로 감싸면 에러가 해결된다. 이걸 사용하면 비동기적으로 실행하는듯 그래서 UI 그려지기 까지 기다려주는 것 같음.\r\n\r\n\r\n## Sealed class based\r\n---\r\n\r\n특징은 multi class 이다.\r\n\r\n\r\n## 절차\r\n\r\n1. sealed class를 만든다.\r\n\r\n```dart\r\nsealed class StateClass {\r\n  const StateClass();\r\n}\r\n```\r\n\r\n2. StateClass를 extend하여 init, loading, success, fail을 구현한다.\r\n\r\n```dart\r\nfinal class StateClassInit extends StateClass {\r\n  const StateClassInit();\r\n\r\n  @override\r\n  String toString() => 'StateClass()';\r\n}\r\n```\r\n\r\n3. provider에서 state 할당할 때 copyWith을 사용하는게 아니라 구현한 class를 사용한다. 나머지는 비슷\r\n\r\n\r\n## async처럼 보이게하는 notifier\r\n---\r\n\r\n### enum\r\n\r\nsetInit 대신에 provider에서 build함수 안에 fetch해주면 된다.\r\n\r\n```dart\r\n  @override\r\n  StateClass build() {\r\n    fetchActivity(types[0]);\r\n    return StateClass.init();\r\n  }\r\n\r\n```\r\n\r\n### 주의할 점\r\n\r\n이 때도 위처럼만 해버리면 에러가난다.\r\n\r\nfuture.delayed로 감싸는 것이 아닌 state에 init()을 먼저 할당해준다.\r\n\r\n```dart\r\n  @override\r\n  StateClass build() {\r\n    state = StateClass.init();\r\n    fetchActivity(types[0]);\r\n    return StateClass.init();\r\n  }\r\n```\r\n\r\n\r\n## AsyncNotifier\r\n---\r\n\r\n방식은 Notifier와 비슷하지만 안에 생성하는 메서드들은  모두 `Future<void>`타입이다.\r\n\r\n`AsyncValue`가 좋은게 `AsyncLoading`에서 이전값을 가지고 있고 `AsyncData`에서 바뀐 next값을 가지고 있다.\r\n\r\n`AsyncError`에서도 value에는 이전값 보유한다.\r\n\r\n### guard\r\n\r\nAsync할 때 try catch문에서 보통 try에 AsyncData, catch에선 AsyncError을 정의합니다. 이를 간소화시켜주는 방법입니다.\r\n\r\n\r\n```dart\r\nstate = await AsyncValue.guard(() async {\r\n  await wait();\r\n  return state.value! + 1;\r\n});\r\n```\r\n\r\n이렇게 하면 알아서 AsyncData와 AsyncError에 값을 넣어준다.\r\n\r\n### riverpod annotation 절차\r\n\r\n1. riverpodpart\r\n\r\n2. riverpodAsyncClass / 작명 / build함수 타입 지정\r\n\r\n3. build에 async 추가 및 family 할거면 build에 인자 추가 \r\n\r\n4. 추가 값들 추가\r\n\r\n\r\n```dart\r\nFutureOr<int> build({required int init}) async {\r\n    \r\n    return init;\r\n  }\r\n```\r\n\r\nriverpod annotation 사용하면 named parameter 사용할 수 있다.\r\n\r\n\r\n### skip error\r\n\r\n`AsyncValue`의 `when` 메서드 사용 시 `skipError` 속성이 있다.\r\n\r\n이 속성은 default가 false고 true로 바꾸면 에러 발생 시 error: 로직에 처리된게 실행되는게 아닌 data가 있다면 이전 데이터를 보여주는 것이다."
    },
    {
      "id": "flutter-til-18",
      "metadata": {
        "permalink": "/blog/flutter-til-18",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-17-til18/index.md",
        "source": "@site/blog/2024-01-17-til18/index.md",
        "title": "Flutter TIL - 18",
        "description": "---",
        "date": "2024-01-17T00:00:00.000Z",
        "formattedDate": "January 17, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "notifierProvider",
            "permalink": "/blog/tags/notifier-provider"
          }
        ],
        "readingTime": 1.645,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-18",
          "title": "Flutter TIL - 18",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "notifierProvider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 19",
          "permalink": "/blog/flutter-til-19"
        },
        "nextItem": {
          "title": "Flutter TIL - 17",
          "permalink": "/blog/flutter-til-17"
        }
      },
      "content": "---\r\n\r\n## ListView\r\n---\r\n\r\n`ListView` 위젯을 `Column/Row`위젯 아래에 둔다면 `ListView`와 `Column/Row`의 사이즈들이 unbounded height가 일어나서 render overflow가 납니다.\r\n\r\n`Column/Row` 아래에 `ListView`를 두고 싶다면 `Expanded` 위젯으로 `ListView`를 감싸야 함.\r\n\r\n## Notifier Provider\r\n---\r\n\r\n### 생성\r\n\r\nnotifier를 입력해서 먼저 notifier를 정의한다.\r\n\r\n```dart\r\nclass CounterNotifier extends Notifier<int> {\r\n  @override\r\n  int build() {\r\n    return 0;\r\n  }\r\n}\r\n```\r\n\r\n`CounterNotifier`는 Notifier의 이름이고 `Notifier<int>`로 돼있는데 int는 반환 타입이다. build함수 앞에는 반환 타입을 붙여줘야 한다.\r\n\r\n`StateNotifier`나 `ChangeNotifier`를 사용하면 `ref`를 사용할 수 없지만(사용하려면 생성자에서 정의해줘야 한다.) `Notifier`를 사용하면 `ref`를 바로 사용할 수 있다.\r\n\r\n\r\n### tear-offs 지원\r\n\r\n```dart\r\nonPressed:(){\r\n  func();\r\n}\r\n\r\n# 위와 아래는 같다.\r\n\r\nonPressed: func,\r\n```\r\n\r\n위 코드와 같은 동작을 하는 것이 tear-offs다.\r\n\r\n거추장스러운 부분이 제거가 된다. 함수와 생성자에서 사용할 수 있다.\r\n\r\n그래서 아래와 같이 `notifierProvider`를 선언할 수 있다.\r\n```dart\r\nfinal counterProvider = NotifierProvider<Counter, int>(() {\r\n  return Counter();\r\n});\r\n\r\n#위를 아래처럼\r\n\r\nfinal counterProvider = NotifierProvider<Counter, int>(Counter.new);\r\n```\r\n\r\n모르면 일단 외우자 tear-offs\r\n\r\n\r\n### 접근\r\n\r\nwatch하면 state값을 가져올 수 있고 인스턴스에 접근하려면\r\n\r\n```dart\r\nref.raed(counterProvider.notifier).increment();\r\n```\r\n\r\n이렇게 할 수 있다."
    },
    {
      "id": "flutter-til-17",
      "metadata": {
        "permalink": "/blog/flutter-til-17",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-16-til17/index.md",
        "source": "@site/blog/2024-01-16-til17/index.md",
        "title": "Flutter TIL - 17",
        "description": "---",
        "date": "2024-01-16T00:00:00.000Z",
        "formattedDate": "January 16, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "FutureProvider",
            "permalink": "/blog/tags/future-provider"
          },
          {
            "label": "refresh",
            "permalink": "/blog/tags/refresh"
          },
          {
            "label": "invalidate",
            "permalink": "/blog/tags/invalidate"
          }
        ],
        "readingTime": 0.725,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-17",
          "title": "Flutter TIL - 17",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "FutureProvider",
            "refresh",
            "invalidate"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 18",
          "permalink": "/blog/flutter-til-18"
        },
        "nextItem": {
          "title": "Flutter TIL - 16",
          "permalink": "/blog/flutter-til-16"
        }
      },
      "content": "---\r\n\r\n## invalidate\r\n---\r\n\r\n```dart\r\nonPressed: () async {\r\n  ref.invalidate(userDetailProvider);\r\n},\r\n```\r\n\r\nrefresh할 때 `invalidate`를 사용한다면 위처럼 onPressed 함수를 구현할 수 있습니다. 물론 skipLoadingOnRefresh도 적용했습니다.\r\n\r\n`invalidate`의 인자값 타입은 `ProviderOrFamily`이다. 그래서 Family를 주지 않고 적용한다면 모든 provider가 auto dispose된다.\r\n\r\n## refresh\r\n---\r\n\r\n```dart\r\nonPressed: () async {\r\n  return ref.refresh(userDetailProvider(userId));\r\n},\r\n```\r\n\r\n또는\r\n\r\n```dart\r\nonPressed: () {\r\n  return ref.refresh(userDetailProvider(userId).future);\r\n},\r\n```\r\n\r\nrefresh 인자 타입은 Family Provider라면 family값을 넘겨주어야 한다. 그리고 return을 사용해야 하기에 return값이 없다면 invalidate를 추천한다."
    },
    {
      "id": "flutter-til-16",
      "metadata": {
        "permalink": "/blog/flutter-til-16",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-15-til16/index.md",
        "source": "@site/blog/2024-01-15-til16/index.md",
        "title": "Flutter TIL - 16",
        "description": "---",
        "date": "2024-01-15T00:00:00.000Z",
        "formattedDate": "January 15, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "FutureProvider",
            "permalink": "/blog/tags/future-provider"
          }
        ],
        "readingTime": 0.81,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-16",
          "title": "Flutter TIL - 16",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "FutureProvider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 17",
          "permalink": "/blog/flutter-til-17"
        },
        "nextItem": {
          "title": "Flutter TIL - 15",
          "permalink": "/blog/flutter-til-15"
        }
      },
      "content": "---\r\n\r\n## skipLoadingOnRefresh\r\n---\r\n\r\nwhen 메서드에서 `skipLoadingOnRefresh`라는 메서드가 있는데 true가 디폴트다. 새로고침해도 loading 창 안보여주는건데 false로 해주는 편이 좋다.\r\n\r\n## 새로고침\r\n---\r\n\r\n`ref.refresh()` 또는 `ref.invalidate()`를 사용한다. 예시로는 `RefreshIndicator`로 했지만 버튼으로 하는게 좋은 UI라고 하는 듯\r\n\r\n그리고 윈도우에서는 `RefreshIndicator` 동작안한다..\r\n\r\n## freezed class override\r\n---\r\n\r\n```dart\r\n@freezed\r\nclass User with _$User {\r\n  const User._();\r\n  \r\n  ...\r\n  @override\r\n  String toString() => 'User(id:$id)';\r\n}\r\n```\r\n\r\nfreezed data class 에서 User._()를 선언하고 toString을 다시 오버라이딩 할 수 있던데 이에 대해서 조금 더 알아봐야 할 듯"
    },
    {
      "id": "flutter-til-15",
      "metadata": {
        "permalink": "/blog/flutter-til-15",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-11-til15/index.md",
        "source": "@site/blog/2024-01-11-til15/index.md",
        "title": "Flutter TIL - 15",
        "description": "---",
        "date": "2024-01-11T00:00:00.000Z",
        "formattedDate": "January 11, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "FutureProvider",
            "permalink": "/blog/tags/future-provider"
          }
        ],
        "readingTime": 2.175,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-15",
          "title": "Flutter TIL - 15",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "FutureProvider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 16",
          "permalink": "/blog/flutter-til-16"
        },
        "nextItem": {
          "title": "Flutter TIL - 14",
          "permalink": "/blog/flutter-til-14"
        }
      },
      "content": "---\r\n\r\n## 가상 API\r\n---\r\n\r\n[여기](https://jsonplaceholder.typicode.com) 에서 다양한 API를 제공해준다.\r\n\r\nusers API로 FutureProvider 실습을 한다.\r\n\r\n\r\n## autoDispose 사용 여부\r\n---\r\n\r\n만약 특정 페이지 진입 시 API를 통해서 값을 가져왔을 때 이 값을 캐싱 할 것이면 `autoDispose` 사용하면 안되고 다시 안 가져올 것이면 `autoDispose` 사용하는 것이 좋다.\r\n\r\n설정값 같은 경우는 API를 쏴서 변경하는 경우가 거의 없으므로 캐싱 하는 것이 좋다.\r\n\r\n\r\n## future provider body\r\n---\r\n\r\n### when\r\n\r\n값을 불러올 때 when을 사용한 모습입니다.\r\n\r\n```dart\r\nbody: userList.when(\r\n  data: (users) {\r\n    return ListView.separated(\r\n      itemCount: users.length,\r\n      separatorBuilder: (context, index) {\r\n        return const Divider();\r\n      },\r\n      itemBuilder: (context, index) {\r\n        final user = users[index];\r\n        return ListTile(\r\n          leading: CircleAvatar(\r\n            child: Text(user.id.toString()),\r\n          ),\r\n          title: Text(user.name),\r\n        );\r\n      },\r\n    );\r\n  },\r\n  error: (e, st) {\r\n    return Text(\r\n      e.toString(),\r\n      style: const TextStyle(fontSize: 20, color: Colors.red),\r\n    );\r\n  },\r\n  loading: () => const Center(\r\n    child: CircularProgressIndicator(),\r\n  ),\r\n),\r\n```\r\n\r\n\r\n\r\n### switch expression\r\n\r\n값을 불러올 때 switch를 사용한 모습입니다.\r\n\r\n```dart\r\nbody: switch (userList) {\r\n  AsyncData(value: final users) => ListView.separated(\r\n      itemCount: users.length,\r\n      separatorBuilder: (context, index) {\r\n        return const Divider();\r\n      },\r\n      itemBuilder: (context, index) {\r\n        final user = users[index];\r\n        return ListTile(\r\n          leading: CircleAvatar(\r\n            child: Text(user.id.toString()),\r\n          ),\r\n          title: Text(user.name),\r\n        );\r\n      },\r\n    ),\r\n  AsyncError(error: final e) => Text(\r\n      e.toString(),\r\n      style: const TextStyle(fontSize: 20, color: Colors.red),\r\n    ),\r\n  _ => const Center(\r\n      child: CircularProgressIndicator(),\r\n    ),\r\n},\r\n```\r\n\r\n마지막에 원래 `_` 대신 `AsyncLoading`이 들어가야 하지만 무슨 에러가 난다.\r\n\r\nuserListProvider를 `@Sealed`로 만들었어야 한다고 한다.\r\n\r\n## keepalive\r\n---\r\n\r\n하면서 궁금증이 생겼었는데 값을 가져왔으면 다시 나갔다 왔을 때 loading 안 보고 싶었습니다.\r\n\r\n그러면 autoDispose일 때 ref.keepAlive()를 사용하면 됩니다.  \r\n주의할 점은 http 호출이 끝나고 적용해야 합니다.\r\n\r\n값을 가져온 것을 성공한 페이지는 값이 유지가 되고(dispose안함)\r\nerror가 나면 dispose 합니다."
    },
    {
      "id": "flutter-til-14",
      "metadata": {
        "permalink": "/blog/flutter-til-14",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-10-til14/index.md",
        "source": "@site/blog/2024-01-10-til14/index.md",
        "title": "Flutter TIL - 14",
        "description": "---",
        "date": "2024-01-10T00:00:00.000Z",
        "formattedDate": "January 10, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "stateprovider",
            "permalink": "/blog/tags/stateprovider"
          },
          {
            "label": "remote api",
            "permalink": "/blog/tags/remote-api"
          },
          {
            "label": "FutureProvider",
            "permalink": "/blog/tags/future-provider"
          }
        ],
        "readingTime": 1.67,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-14",
          "title": "Flutter TIL - 14",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "stateprovider",
            "remote api",
            "FutureProvider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 15",
          "permalink": "/blog/flutter-til-15"
        },
        "nextItem": {
          "title": "Flutter TIL - 12",
          "permalink": "/blog/flutter-til-12"
        }
      },
      "content": "---\r\n\r\n## state provider\r\n---\r\n\r\n특징으로는 code generator가 안되고\r\n\r\nstate를 갖고 있다는 점\r\n\r\n```dart\r\nfloatingActionButton: FloatingActionButton(\r\n  onPressed: () {\r\n    ref.read(counterProvider.notifier).state++;\r\n  },\r\n  child: const Icon(Icons.add),\r\n),\r\n```\r\n\r\n위와 같이 read를 하는데 notifier를 사용해서 state에 접근할 수 있다.\r\n\r\n그리고 추가로 UI를 그리려면 `Future.delay` 또는 Listen을 사용할 수 있다.  \r\n(그냥 그리려면 에러난다. 충돌나서)\r\n\r\n```dart\r\nref.listen<int>(counterProvider, (previous, next) {\r\n  if (next == 3) {\r\n    showDialog(\r\n      context: context,\r\n      builder: (context) {\r\n        return AlertDialog(\r\n          content: Text('counter : $next'),\r\n        );\r\n      },\r\n    );\r\n  }\r\n});\r\n```\r\n\r\n요런식으로 listen할 수 있다. 이전 값 다음 값이 있다.\r\n\r\n## update\r\n---\r\n\r\n```dart\r\nonPressed: () {\r\n  ref\r\n      .read(autoDisposecounterProvider.notifier)\r\n      .update((state) => state + 10);\r\n},\r\n```\r\n\r\n위 코드는\r\n\r\n```dart\r\nref.read(autoDisposecounterProvider.notifier).state + \r\n  ref.read(autoDisposecounterProvider.notifier).state + 10\r\n```\r\n\r\n과 같은 코드이다. 너무 길기 때문에 그냥 update 사용하는 것이 편리하다.\r\n\r\nstate를 인자로 사용할 로직이 필요하면 `update` 사용하기\r\n\r\n## Future Provider의 이야기\r\n---\r\n\r\nremote api를 호출하면 3가지 상태 처리가 필요하다.\r\n\r\n`in progress`, `success`, `error`이다.\r\n\r\n3가지 모두 동시에 2가지 이상 상태가 될 수 없다.\r\n\r\n`FutureProvider`는 이 3가지 상태에 대한 값을 처리해준다.\r\n\r\n`AsyncData`, `AsyncError`, `AsyncLoading`이 있다.\r\n\r\n생성자도 3가지 있다.\r\n\r\n`AsyncValue`가 중요하다는 뜻\r\n\r\n## 소소한 팁\r\n---\r\n\r\n1. provider 안에 ref.read()를 사용하지 말 것\r\n\r\n2. StateProvider 대신 NotifierProvider 사용할 것"
    },
    {
      "id": "flutter-til-12",
      "metadata": {
        "permalink": "/blog/flutter-til-12",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-09-til12/index.md",
        "source": "@site/blog/2024-01-09-til12/index.md",
        "title": "Flutter TIL - 12",
        "description": "---",
        "date": "2024-01-09T00:00:00.000Z",
        "formattedDate": "January 9, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "provider",
            "permalink": "/blog/tags/provider"
          }
        ],
        "readingTime": 2.485,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-12",
          "title": "Flutter TIL - 12",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "provider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 14",
          "permalink": "/blog/flutter-til-14"
        },
        "nextItem": {
          "title": "Flutter TIL - 13",
          "permalink": "/blog/flutter-til-13"
        }
      },
      "content": "---\r\n\r\n```dart\r\nfinal helloProvider = Provider<String>((ref) {\r\n  ref.onDispose(() {\r\n    print(\"[helloProvider] : disposed\");\r\n  });\r\n  return \"Hello\";\r\n});\r\n```\r\n\r\nriverpod의 기본 모습이 이렇다.\r\n\r\n변수에 할당하고 `Provider` 부분은 사용할 Provider 종류,\r\n\r\n`<String>`에는 return값 타입을 정의한다.\r\n\r\nref를 통해서 여러 기능을 사용할 수 있는데 ref.onDispose해주면 dispose된다.\r\n\r\n### onDispose\r\n\r\n해당 provider가 dispose되면 실행되는 함수\r\n\r\n위의 코드는 자동으로 dispose 되지 않는다.\r\n\r\n### 대표적 3가지\r\n\r\n`watch` : 값 변하는지 계속 확인하고 변하면 리빌드 (async하면안된다.)\r\n\r\n`listen` : 값 변경되면 리빌딩 되는 것이 아닌 액션을 수행(navigate같은) (async하면 안된다.)\r\n\r\n`read` : 값을 확인하지만 변경을 watch하지 않음(build에서 사용하지마라)\r\n\r\n## auto dispose\r\n---\r\n\r\n```dart\r\nfinal autoDisposeHelloProvider = Provider.autoDispose<String>((ref) {\r\n  print('[autoDisposeHelloProvder]: created');\r\n  ref.onDispose(() {\r\n    print('[autoDisposeHelloProvder]: disposed');\r\n  });\r\n  return 'Hello';\r\n});\r\n```\r\n\r\n페이지에서 나오면 autodispose해준다.\r\n\r\n## family\r\n---\r\n\r\n```dart\r\nfinal familyHelloProvider = Provider.family<String, String>((ref, name) {\r\n  ref.onDispose(() {\r\n    print('[familyHelloProvider] disposed');\r\n  });\r\n  return 'Hello $name';\r\n});\r\n```\r\n이렇게 provider 정의하면 argument 사용할 수 있다.\r\n\r\n```dart\r\n    final helloA = ref.watch(familyHelloProvider('A'));\r\n    final helloB = ref.watch(familyHelloProvider('B'));\r\n```\r\nwatch할 때도 이런식으로 해야한다.\r\n\r\n## autoDisposeFamily\r\n---\r\n\r\n```dart\r\nfinal autoDisposeFamilyHelloProvider =\r\n    Provider.autoDispose.family<String, String>((ref, name) {\r\n  ref.onDispose(() {\r\n    print('[autoDisposeFamilyHelloProvider] disposed');\r\n  });\r\n  return 'Hello $name';\r\n});\r\n```\r\nautoDispose와 family를 모두 사용할 수 있다.\r\n\r\n만약 둘의 인자값이 `A`라면 dispose는 한번만 일어납니다. (그냥 autoDispose도 한번만 일어남)\r\n\r\n\r\n## 객체 넘기기 \r\n---\r\n\r\n```dart\r\nclass Counter {\r\n  final int count;\r\n  Counter({\r\n    required this.count,\r\n  });\r\n\r\n  @override\r\n  String toString() => 'Counter()(count: $count)';\r\n}\r\n\r\nfinal counterProvider = Provider.autoDispose.family<int, Counter>((ref, c) {\r\n  ref.onDispose(() {\r\n    print('[countProvider($c)] disposed');\r\n  });\r\n  return c.count;\r\n});\r\n```\r\n\r\n만약 위처럼 객체를 넘겨서\r\n\r\n```dart\r\n    ref.watch(counterProvider(Counter(count: 0)));\r\n    ref.watch(counterProvider(Counter(count: 0)));\r\n```\r\n\r\n이렇게 watch를 조지면 dispose가 두번 일어납니다. 둘 다 다른 객체로 판단합니다.\r\n\r\n\r\n```dart\r\nclass Counter extends Equatable {\r\n  final int count;\r\n  const Counter({\r\n    required this.count,\r\n  });\r\n\r\n  @override\r\n  String toString() => 'Counter()(count: $count)';\r\n\r\n  @override\r\n  List<Object> get props => [count];\r\n}\r\n```\r\n\r\nCounter 객체를 Equatable해야 dispose 한번만 일어난다.\r\n\r\n\r\n## 정리\r\n---\r\n\r\nautoDispose 조심히 사용해야 한다. 계속 dispose 하기 때문에"
    },
    {
      "id": "flutter-til-13",
      "metadata": {
        "permalink": "/blog/flutter-til-13",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-09-til13/index.md",
        "source": "@site/blog/2024-01-09-til13/index.md",
        "title": "Flutter TIL - 13",
        "description": "---",
        "date": "2024-01-09T00:00:00.000Z",
        "formattedDate": "January 9, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "revierpod",
            "permalink": "/blog/tags/revierpod"
          },
          {
            "label": "code generator",
            "permalink": "/blog/tags/code-generator"
          },
          {
            "label": "provider",
            "permalink": "/blog/tags/provider"
          },
          {
            "label": "stateProvider",
            "permalink": "/blog/tags/state-provider"
          }
        ],
        "readingTime": 2.39,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-13",
          "title": "Flutter TIL - 13",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "revierpod",
            "code generator",
            "provider",
            "stateProvider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 12",
          "permalink": "/blog/flutter-til-12"
        },
        "nextItem": {
          "title": "Flutter TIL - 11",
          "permalink": "/blog/flutter-til-11"
        }
      },
      "content": "---\r\n\r\n## code generator\r\n---\r\n\r\n`rivp`: `riverpodPart`\r\n\r\n```dart\r\npart 'b_provider.g.dart';\r\n```\r\n\r\n`riverpodKeepAlive`\r\n\r\nriverpod code generator는 자동으로 autoDispose인데 keepAlive:true를 해주면 autoDispose하지 않는다.\r\n\r\n```dart\r\n@Riverpod(keepAlive: true)\r\nString hello(HelloRef ref) {\r\n  ref.onDispose(() {\r\n    print(\"[helloProvider] : disposed\");\r\n  });\r\n  return \"Hello\";\r\n}\r\n```\r\n\r\n`String`: return의 타입\r\n`hello`: 나중에 helloProvider라는 이름을 갖는다.\r\n`HelloRef`: generator하면 Ref로 나오는데 hello에서 앞글자를 대문자로 해서 붙이면 HelloRef가 된다. 이걸로 교체해줘야한다.\r\n\r\n### 코드생성\r\n\r\n```bash\r\ndart run build_runner build -d\r\n```\r\n\r\n위 처럼 build runner 실행해서 generate할 수 있다.\r\n\r\n`-d`옵션은 generate중 충돌이 나도 그냥 생성하라는 뜻입니다.\r\n\r\n```bash\r\ndart run build_runner watch -d\r\n```\r\n\r\nwatch를 사용하면 한번만 사용하면 변화를 계속 watch해서 적용된다.\r\n\r\n### 차이점\r\n\r\n수동 생성과 차이점은\r\n\r\n1. 기존은 `helloProvider` 이렇게 했다면 자동 생성에서는 hello로만 해도 `helloProvider` 생성해줌.\r\n\r\n2. 자동생성에서는 Provider 종류 지정 안해도된다.\r\n\r\n\r\n## Provider\r\n---\r\n\r\n### autoDispose\r\n---\r\n\r\nautoDispose Provider는 `riverpod`스니팻 으로 만들 수 있습니다.\r\n\r\n```dart\r\n@riverpod\r\nString autoDisposeHello(AutoDisposeHelloRef ref) {\r\n  print('[autoDisposeHelloProvder]: created');\r\n  ref.onDispose(() {\r\n    print('[autoDisposeHelloProvder]: disposed');\r\n  });\r\n  return 'Hello';\r\n}\r\n```\r\n\r\n\r\n\r\n### family\r\n---\r\n\r\nfamily는 그냥 `riverpod`이나 `riverpodkeepalive`에서  ref 옆에 파라미터 추가해주면 family로 자동으로 만들어줍니다.\r\n\r\n```dart\r\n@Riverpod(keepAlive: true)\r\nString familyHello(FamilyHelloRef ref, {required String name}) {\r\n  ref.onDispose(() {\r\n    print('[familyHelloProvider] disposed');\r\n  });\r\n  return 'Hello $name';\r\n}\r\n```\r\n\r\n참고로 `name`을 사용하면 에러난다. 그 이유는 generator에서 name이라는 변수를 이미 사용하고 있기 때문이다.\r\n\r\n### autoDispose, family\r\n---\r\n\r\n```dart\r\n@riverpod\r\nString autoDisposeFamilyHello(AutoDisposeFamilyHelloRef ref,\r\n    {required String nom}) {\r\n  ref.onDispose(() {\r\n    print('[autoDisposeFamilyHelloProvider] disposed');\r\n  });\r\n  return 'Hello $nom';\r\n}\r\n```\r\n\r\n별로 어렵지 않음\r\n\r\n## 한가지 배운 dart 언어 syntax\r\n---\r\n\r\n`part`는 `import`다음으로 최상단에 위치해야한다.\r\n\r\n\r\n## StateProvider\r\n---\r\n\r\n### 특징\r\n\r\n- stateProvider는 notifierProvider의 간소화된 버전  \r\n- 복잡하지 않는 로직을 쓸 때 사용  \r\n- code generator해서 만들 수 없다.(수동만 가능)"
    },
    {
      "id": "flutter-til-11",
      "metadata": {
        "permalink": "/blog/flutter-til-11",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-08-til11/index.md",
        "source": "@site/blog/2024-01-08-til11/index.md",
        "title": "Flutter TIL - 11",
        "description": "---",
        "date": "2024-01-08T00:00:00.000Z",
        "formattedDate": "January 8, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "freezed",
            "permalink": "/blog/tags/freezed"
          },
          {
            "label": "json_annotation",
            "permalink": "/blog/tags/json-annotation"
          },
          {
            "label": "riverpod",
            "permalink": "/blog/tags/riverpod"
          },
          {
            "label": "provider",
            "permalink": "/blog/tags/provider"
          }
        ],
        "readingTime": 2.015,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-11",
          "title": "Flutter TIL - 11",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "freezed",
            "json_annotation",
            "riverpod",
            "provider"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 13",
          "permalink": "/blog/flutter-til-13"
        },
        "nextItem": {
          "title": "Flutter TIL - 10",
          "permalink": "/blog/flutter-til-10"
        }
      },
      "content": "---\r\n\r\n## factory Constructor\r\n---\r\n\r\nfactory constructor의 constructor redirection에 대해 알고 있어야 한다. 그리고 const를 사용할 수 있음.\r\n\r\n## 필요한 패키지\r\n---\r\n\r\n`freezed_annotation`: dep : 코드 생성기에 대한 어노테이션 패키지\r\n\r\n`build_runner` : dev-dep : 코드 생성기 실행\r\n\r\n`freezed` : dev-dep : 코드 생성기\r\n\r\n`json_annotation` : dep : 코드 생성기인 json_serializable의 어노테이션 갖고 있는 패키지\r\n\r\n`json_serializable` : dev-dep : 코드 생성기\r\n\r\n### freezed와 json_serializable 사용할 경우\r\n\r\nanalysis_options.yaml에 설정\r\n\r\n```yaml\r\nanalyzer:\r\n  errors:\r\n    invalid_annotation_target: ignore\r\n  exclude:\r\n    - '**/*.freezed.dart'\r\n    - '**/*.g.dart'\r\n```\r\n\r\n### build runner를 사용해서 코드 gen하려면\r\n\r\n```bash\r\ndart run build_runner build [--delete-conflicting-outputs]\r\n\r\nor\r\n\r\ndart run build_runner watch [-d]\r\n```\r\n\r\nbuild는 one-time, watch는 계속 빌드함\r\n\r\nwatch가 빌드 타임 적다.\r\n\r\n`[]`에 있는 옵션은 previous build에서 발생한 것 건너뛰기\r\n\r\n\r\n## extension\r\n\r\n`freezed`라는 확장 설치해야 한다.\r\n\r\n`ptf` : part '*.freezed.dart'; 생성\r\n`pts` : part '*.g.dart'; 생성\r\n`fdataclass` : Dataclass 생성\r\n`funion` : Union class 생성\r\n\r\n\r\n## 기능\r\n---\r\n\r\n### 정리\r\n\r\n우선 다양한 것들을 override해준다.\r\n\r\ntoString이나 copyWith, equality 등을 오버라이딩 해줌.\r\n\r\n### copyWith\r\n\r\n일반적인 copyWith + null도 지원해줌\r\n\r\ndeep copyWith도 제공해준다. 복잡한 코드를 간단하게 작성할 수 있도록 지원\r\n\r\n### Json annotation\r\n\r\n```dart\r\n@JsonKey(name: 'parking_lot_capacity') int? parkingLotcapacity,\r\n```\r\n\r\ndata class를 만들 때 이런 인자값을 볼 수 있다.\r\n\r\n변수 parkingLotcapacity를 json키 값 'parking_lot_capacity'로 판단하겠다는 뜻이다.\r\n\r\n```dart\r\n  factory Hotel.fromJson(Map<String, dynamic> json) => _$HotelFromJson(json);\r\n```\r\n\r\n이런 것도 제공해준다.\r\n\r\n## Provider\r\n---\r\n\r\n위젯이나 다른 Provider에 값을 제공\r\n\r\nriverpod에서는 Provider를 watch할 수 있다.\r\n그리고 그냥 값을 제공하는 Provider다.\r\n\r\n### dep\r\n\r\n`equatable`,`flutter_riverpod`,`riverpod_annotation`\r\n\r\n### dev-dep\r\n\r\n`build_runner`,`custom_lint`,`flutter_lints`,`riverpod_generator`, `riverpod_lint`"
    },
    {
      "id": "flutter-til-10",
      "metadata": {
        "permalink": "/blog/flutter-til-10",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-08-til10/index.md",
        "source": "@site/blog/2024-01-08-til10/index.md",
        "title": "Flutter TIL - 10",
        "description": "---",
        "date": "2024-01-08T00:00:00.000Z",
        "formattedDate": "January 8, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "개념",
            "permalink": "/blog/tags/개념"
          },
          {
            "label": "mutex",
            "permalink": "/blog/tags/mutex"
          },
          {
            "label": "semaphore",
            "permalink": "/blog/tags/semaphore"
          }
        ],
        "readingTime": 0.995,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-10",
          "title": "Flutter TIL - 10",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "개념",
            "mutex",
            "semaphore"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 11",
          "permalink": "/blog/flutter-til-11"
        },
        "nextItem": {
          "title": "Flutter TIL - 9",
          "permalink": "/blog/flutter-til-9"
        }
      },
      "content": "---\r\n\r\n## mutex와 semaphore 차이\r\n---\r\n\r\n### mutex\r\n\r\n공유된 자원에 스레드들의 동시 접근을 막아줍니다. 1개의 프로세스 혹은 쓰레드만 공유 자원에 접근할 수 있습니다. 키를 기반으로 한 상호배제 기법입니다.\r\n\r\n공유된 자원을 카페 화장실로 비유할 수 있고 키를 열쇠로 비유할 수 있습니다.\r\n\r\n### semaphore\r\n\r\n세마포어도 동시 접근을 막아주는데 1개의 프로세스만 접근할 수 있는 것이 아닌 여러 설정된 최대값 만큼 들어갈 수 있습니다. 빈칸이 0이면 대기해야 합니다.\r\n\r\n공유된 자원을 카페 화장실인데 칸이 여러 개 있는 화장실로 비유할 수 있습니다."
    },
    {
      "id": "flutter-til-9",
      "metadata": {
        "permalink": "/blog/flutter-til-9",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-04-til9/index.md",
        "source": "@site/blog/2024-01-04-til9/index.md",
        "title": "Flutter TIL - 9",
        "description": "---",
        "date": "2024-01-04T00:00:00.000Z",
        "formattedDate": "January 4, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "data class generator",
            "permalink": "/blog/tags/data-class-generator"
          },
          {
            "label": "equatable",
            "permalink": "/blog/tags/equatable"
          },
          {
            "label": "json",
            "permalink": "/blog/tags/json"
          }
        ],
        "readingTime": 1.13,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-9",
          "title": "Flutter TIL - 9",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "data class generator",
            "equatable",
            "json"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 10",
          "permalink": "/blog/flutter-til-10"
        },
        "nextItem": {
          "title": "Flutter TIL - 8",
          "permalink": "/blog/flutter-til-8"
        }
      },
      "content": "---\r\n\r\n## Equatable\r\n---\r\n\r\n`dart class generator`라는 vs code extension을 사용할 때 객체 비교를 위해서 `equatable`이라는 dart 패키지를 이용할 수 있습니다.\r\n\r\nvs code preferences에서 equatable 관련 설정을 `true`로 변경한다면 generator를 이용할 수 있습니다.\r\n\r\n함수를 통해 객체를 생성하면 주소 값이 달라져서 같은 값을 갖고 있는 객체를 비교해도 false로 나오는데 `equatable`을 이용해서 비교하면 true를 반환할 수 있습니다.\r\n\r\n## Json 관련\r\n---\r\n\r\njson object로 자동 data class가 생성되는 마법이 있다고 합니다.\r\n\r\n1. 일단 dart 파일을 만듭니다.\r\n\r\n2. api 응답 json 값을 넣습니다.\r\n\r\n3. `ctrl`+`shift`+`p`해서 Generate from JSON 입력해서 선택\r\n\r\n4. class 이름 입력\r\n\r\n5. no 선택\r\n\r\n그럼 data class 자동 생성 해준다.\r\n\r\nfromMap, toMap만 잘 확인해보면 된다. (beta 단계임)"
    },
    {
      "id": "flutter-til-8",
      "metadata": {
        "permalink": "/blog/flutter-til-8",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-01-03-til8/index.md",
        "source": "@site/blog/2024-01-03-til8/index.md",
        "title": "Flutter TIL - 8",
        "description": "---",
        "date": "2024-01-03T00:00:00.000Z",
        "formattedDate": "January 3, 2024",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "tree-view",
            "permalink": "/blog/tags/tree-view"
          }
        ],
        "readingTime": 0.62,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-8",
          "title": "Flutter TIL - 8",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "tree-view"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 9",
          "permalink": "/blog/flutter-til-9"
        },
        "nextItem": {
          "title": "Flutter TIL - 7",
          "permalink": "/blog/flutter-til-7"
        }
      },
      "content": "---\r\n\r\n## Treeview\r\n---\r\n\r\n[이 라이브러리](https://pub.dev/packages/animated_tree_view)를 사용한다.\r\n\r\n`animated_tree_view`다.\r\n\r\n`TreeNode.root`에 `..addAll([])` 해서 배열을 넣을 수 있다.\r\n\r\n```dart\r\n  final myTree = TreeNode.root()\r\n    ..addAll([\r\n      TreeNode(key: \"Today\"),\r\n      TreeNode(key: \"Tomorrow\")\r\n        ..addAll([\r\n          TreeNode(key: \"task 1\"),\r\n          TreeNode(key: \"task 2\"),\r\n          TreeNode(key: \"task 3\"),\r\n        ]),\r\n      TreeNode(key: \"Upcoming\"),\r\n    ]);\r\n```\r\n\r\n`TreeView.simple`을 사용해봤는데 builder에서 인자로 `context`, `node`를 받는다.\r\n\r\n주의할 점은 key로 하기 때문에 key 중복되지 않게 조심해야한다. 같은 level만 아니면 괜찮다. (같은 level아니면 이름 중복 가능)"
    },
    {
      "id": "flutter-til-7",
      "metadata": {
        "permalink": "/blog/flutter-til-7",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-28-til7/index.md",
        "source": "@site/blog/2023-12-28-til7/index.md",
        "title": "Flutter TIL - 7",
        "description": "---",
        "date": "2023-12-28T00:00:00.000Z",
        "formattedDate": "December 28, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "future_wait",
            "permalink": "/blog/tags/future-wait"
          }
        ],
        "readingTime": 0.54,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-7",
          "title": "Flutter TIL - 7",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "future_wait"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 8",
          "permalink": "/blog/flutter-til-8"
        },
        "nextItem": {
          "title": "Git - LF will be replaced by CRLF the next time Git touches it",
          "permalink": "/blog/git-error-1"
        }
      },
      "content": "---\r\n\r\n## Future.wait\r\n---\r\n\r\n```dart\r\n  Future<void> searchProductList() async {\r\n    isBusy = true;\r\n    final results = await Future.wait([\r\n      productRepository.searchProductList(keyword),\r\n      Future.delayed(const Duration(milliseconds: 555)),\r\n    ]);\r\n    productList = results[0];\r\n    isBusy = false;\r\n  }\r\n```\r\n\r\n`Future.wait`이라는게 있는데 안에 있는 Future wait의 배열 명령어들이 모두 끝날 때까지 기다림\r\n\r\n즉 위 코드 상으로는 search하는거와 delayed를 동시에 돌리는데 555 millisecond는 무조건 돌고 그 이상은 search끝날 때까지 기다린다는 뜻"
    },
    {
      "id": "git-error-1",
      "metadata": {
        "permalink": "/blog/git-error-1",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-28-error1/index.md",
        "source": "@site/blog/2023-12-28-error1/index.md",
        "title": "Git - LF will be replaced by CRLF the next time Git touches it",
        "description": "---",
        "date": "2023-12-28T00:00:00.000Z",
        "formattedDate": "December 28, 2023",
        "tags": [
          {
            "label": "git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 0.11,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "git-error-1",
          "title": "Git - LF will be replaced by CRLF the next time Git touches it",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "git"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 7",
          "permalink": "/blog/flutter-til-7"
        },
        "nextItem": {
          "title": "Git - 변경사항 취소",
          "permalink": "/blog/tip-git-1"
        }
      },
      "content": "---\r\n\r\n## window\r\n---\r\n\r\n```bash\r\ngit config --global core.autocrlf true\r\n```\r\n\r\n## linux, mac\r\n---\r\n\r\n```bash\r\ngit config --global core.autocrlf input\r\n```"
    },
    {
      "id": "tip-git-1",
      "metadata": {
        "permalink": "/blog/tip-git-1",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-28-tip-git1/index.md",
        "source": "@site/blog/2023-12-28-tip-git1/index.md",
        "title": "Git - 변경사항 취소",
        "description": "---",
        "date": "2023-12-28T00:00:00.000Z",
        "formattedDate": "December 28, 2023",
        "tags": [
          {
            "label": "git",
            "permalink": "/blog/tags/git"
          }
        ],
        "readingTime": 0.05,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "tip-git-1",
          "title": "Git - 변경사항 취소",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "git"
          ]
        },
        "prevItem": {
          "title": "Git - LF will be replaced by CRLF the next time Git touches it",
          "permalink": "/blog/git-error-1"
        },
        "nextItem": {
          "title": "Flutter TIL - 6",
          "permalink": "/blog/flutter-til-6"
        }
      },
      "content": "---\r\n\r\n## 명령어\r\n\r\n```bash\r\ngit reset --hard\r\n```"
    },
    {
      "id": "flutter-til-6",
      "metadata": {
        "permalink": "/blog/flutter-til-6",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-27-til6/index.md",
        "source": "@site/blog/2023-12-27-til6/index.md",
        "title": "Flutter TIL - 6",
        "description": "---",
        "date": "2023-12-27T00:00:00.000Z",
        "formattedDate": "December 27, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "listview",
            "permalink": "/blog/tags/listview"
          },
          {
            "label": "clipping",
            "permalink": "/blog/tags/clipping"
          },
          {
            "label": "GestureDetector",
            "permalink": "/blog/tags/gesture-detector"
          },
          {
            "label": "divider",
            "permalink": "/blog/tags/divider"
          }
        ],
        "readingTime": 2.52,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-6",
          "title": "Flutter TIL - 6",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "listview",
            "clipping",
            "GestureDetector",
            "divider"
          ]
        },
        "prevItem": {
          "title": "Git - 변경사항 취소",
          "permalink": "/blog/tip-git-1"
        },
        "nextItem": {
          "title": "Flutter TIL - 5",
          "permalink": "/blog/flutter-til-5"
        }
      },
      "content": "---\r\n\r\n## ClipRRect\r\n---\r\n\r\ncontainer를 border radius하게 디자인 했는데 스크롤 바가 오버플로우 되는 현상이 있었다.\r\n\r\nClipRRect로 스크롤바를 만드는 listview 위젯을 감싸니 오버플로우 되는 부분은 안보이게 됐다.\r\n\r\nClipRRect위젯은 클리핑하는 위젯인데 클리핑이란 주어진 경계 내에서만 내용을 보여주고 경계 넘어서는 잘라내는 것을 의미한다고 한다.\r\n\r\n주로 이미지를 둥근 액자에 넣고 싶을 때도 사용한다고 한다..\r\n\r\n## listView\r\n---\r\n\r\n사실 바보같은 짓을 했다 listView 안에 expanded를 넣으려고 했다. 왜냐하면 width를 double.infinity하게 하고싶었었다. 그러나 listView를 잘 몰랐었다.\r\n\r\nlistView의 자식들은 listView의 크기를 따라간다. 그래서 listView를 Expanded안에 infinity로 두면 그 안에도 infinity다. 그렇게 해결했다.\r\n\r\n## GestureDetector의 behavior\r\n---\r\n\r\n:::tip\r\n`deferToChild`: 자식 중 하나가 적중 시 이벤트 수신(투명한 대상 이벤트 수신 x)  \r\n`translucent` : 반투명한 대상 & 시각적으로 뒤에 있는 대상도 이벤트 수신  \r\n`opaque` : 시각적으로 뒤에 있는 대상은 이벤트 수신 불가능\r\n:::\r\n\r\n```dart\r\nbehavior: HitTestBehavior.translucent,\r\n```\r\n\r\n이와 같이 사용한다면 패딩부분도 클릭한다면 이벤트 수신될 수 있다.\r\n\r\n\r\n## Divider\r\n---\r\n\r\n`ListView.separated`를 사용하여 `separatorBuilder`를 통해 구분자를 넣을 수 있었다.\r\n\r\n줄을 긋고 싶었는데 `Divider`를 사용할 수 있었다.\r\n\r\n`height`로 상하 여백을 정할 수 있었고  \r\n`thickness`로 줄의 굵기를  \r\n`indent`,`endIndent`로 좌우 여백을  \r\n`color`로 색상을 정할 수 있었다.\r\n\r\n## 리랜더링\r\n---\r\n\r\n다국어 지원 설정을 했는데 값은 변경 됐는데 화면 리랜더링을 못해서 계속 애먹었었다. 결국에는 riverpod provider를 수정하여 다국어도 watch하는 방법으로 변경했는데 현업에서 이렇게 사용하는지는 아직 모르겠다.."
    },
    {
      "id": "flutter-til-5",
      "metadata": {
        "permalink": "/blog/flutter-til-5",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-26-til5/index.md",
        "source": "@site/blog/2023-12-26-til5/index.md",
        "title": "Flutter TIL - 5",
        "description": "---",
        "date": "2023-12-26T00:00:00.000Z",
        "formattedDate": "December 26, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "생성자",
            "permalink": "/blog/tags/생성자"
          },
          {
            "label": "constructor",
            "permalink": "/blog/tags/constructor"
          },
          {
            "label": "nullabel",
            "permalink": "/blog/tags/nullabel"
          }
        ],
        "readingTime": 1.675,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-5",
          "title": "Flutter TIL - 5",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "생성자",
            "constructor",
            "nullabel"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 6",
          "permalink": "/blog/flutter-til-6"
        },
        "nextItem": {
          "title": "Flutter TIL - 4",
          "permalink": "/blog/flutter-til-4"
        }
      },
      "content": "---\r\n\r\n## nullable constructor\r\n---\r\n\r\n### 실수한 코드\r\n\r\n처음에 class의 인스턴스를 만들 때 nullable로 선언하면 될 줄 알았다.\r\n\r\n```dart\r\nclass NaviState {\r\n  final int? index;  \r\n  final bool? yesOrNo;  \r\n\r\n  NaviState({\r\n    this.index,\r\n    this.yesOrNo,\r\n  });\r\n}\r\n```\r\n\r\n이렇게 했더니 사용하는 변수 타입이 nullabe이 되어버려서 계속 사용하는 변수 뒤에 `!`를 붙여줘서 null이 아님을 명시했어야 했는데\r\n\r\n### 원했던 코드\r\n\r\n```dart\r\nclass NaviState {\r\n  final int index;\r\n  final bool yesOrNo;\r\n\r\n  NaviState({\r\n    int? index,\r\n    bool? yesOrNo,\r\n  })  : index = index ?? 0,\r\n        yesOrNo = yesOrNo ?? false;\r\n}\r\n```\r\n\r\n이렇게 nullable로 선언하는 것이 아닌 생성자에서 nullable로 받고 null인 경우 초기값을 설정하도록 하는 것이 내가 의도한 방향성과 더 맞는 코드인 것을 알게 됐다.\r\n\r\n\r\n## Navigator.pushNamed\r\n---\r\n\r\nflutter에서 라우팅 하는 방법은 좀 다양한 것 같다.\r\n\r\n그 중 `Navigator.pushNamed`이다.\r\n\r\nNavigator.pushNamed로 context에 불러올 위젯 이름을 push한다.\r\n\r\n그러면 정의해 놓은 `onGenerateRoute`를 통해서 page를 불러오면 된다. 간단하다.\r\n\r\n## GestureDetector 렌더링 문제\r\n---\r\n\r\n갑자기 GestureDetector만 사용하면 렌더링 에러가 났다.\r\n\r\nGestureDetector에 사이즈를 제공해주지 않았기 때문이라고 한다. (ListView도 마찬가지다)\r\n\r\n```dart\r\nExpanded(\r\n  child: SizedBox(\r\n    height: 200,\r\n    width: 200,\r\n    child: GestureDetector(),\r\n  ),\r\n)\r\n```\r\n\r\n이런식으로 구현할 수 있다."
    },
    {
      "id": "flutter-til-4",
      "metadata": {
        "permalink": "/blog/flutter-til-4",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-21-til4/index.md",
        "source": "@site/blog/2023-12-21-til4/index.md",
        "title": "Flutter TIL - 4",
        "description": "---",
        "date": "2023-12-21T00:00:00.000Z",
        "formattedDate": "December 21, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "dart",
            "permalink": "/blog/tags/dart"
          },
          {
            "label": "function",
            "permalink": "/blog/tags/function"
          }
        ],
        "readingTime": 2.565,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-4",
          "title": "Flutter TIL - 4",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "dart",
            "function"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 5",
          "permalink": "/blog/flutter-til-5"
        },
        "nextItem": {
          "title": "Flutter TIL - 3",
          "permalink": "/blog/flutter-til-3"
        }
      },
      "content": "---\r\n\r\n## 선택적 매개변수\r\n---\r\n\r\n```dart\r\nColor getColor(WidgetRef ref, bool isInactive, [Color? color]) {}\r\n```\r\n\r\n위와 같은 함수가 있다고 가정하자. `[Color? color]` 이렇게 대괄호로 받는 매개변수는 넣어도 되고 안 넣어도 되는 선택적 매개변수이다.\r\n\r\n\r\n## svg icon에 대해서\r\n---\r\n\r\n지금 저는 IconButton을 사용하지 않고 Custom으로 Button위젯을 만들어서 사용하고 있습니다.\r\n\r\n이 때 버튼 등 다양한 값들을 `GestureDetector`의 `Row` 위젯으로 감싸아서 했는데 width가 넘어갔다는고 하네요.. 그래서 appbar가 좀 밀려보였습니다.\r\n\r\nsvg파일의 크기를 줄여야 합니다. vs code에서 위젯트리 디버깅 확인해보며 Row에 할당된 width를 확인하고 그 이하로 svg 파일 크기를 줄이면 해결됩니다.\r\n\r\n## NaviagtionRail\r\n---\r\n\r\nnavigationRail을 사용하면 사이드 네비게이션 바를 사용할 수 있다.\r\n\r\n`NavigationRail`안에 `NavigationRailDestination`으로 Navigator를 하나하나 정의할 수 있다.\r\n\r\n`selectedIndex`가 필수로 필요하다.\r\n\r\n`onDestinationSelected`로 어떤 것을 선택했는지 정의할 수 있다. setState로도 할 수 있는데 provider를 사용해서 watch해서 사용할 수도 있다.\r\n\r\n예를 들어서 `selectedIndex`를 state를 watch하고 `onDestinationSelected`에는 값을 바꿔주는 함수를 정의해서 read로 호출하면 될 듯\r\n\r\n`selectedIconTheme`과 `unselectedIconTheme`을 통하여 테마 지정 가능 아직은 큰 필요성 모르겠다.\r\n\r\ntrailing을 사용하면 맨 밑에 버튼 같은 걸 만들 수 있습니다.\r\n\r\n이 과정도 복잡했는데 Expanded와 Align 을 사용해야 할 수 있었습니다. 이에 대해서는 또 찾아봐야겠네요\r\n\r\n## body에 border-radius\r\n---\r\n\r\n사실 body에 border-radius줘도 안바뀐다 왜냐하면 배경색과 색이 같아서\r\n\r\n그래서 body를 이루고 있는 Row위젯을 ColorBox로 감쌉니다. 그렇게 배경색을 주고 밑에서 Container에 해당했던 부분(기존에 border-radius를 줬던 부분)을 Expanded로 확장시킵니다 그럼 끝 !"
    },
    {
      "id": "flutter-til-3",
      "metadata": {
        "permalink": "/blog/flutter-til-3",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-20-til3/index.md",
        "source": "@site/blog/2023-12-20-til3/index.md",
        "title": "Flutter TIL - 3",
        "description": "---",
        "date": "2023-12-20T00:00:00.000Z",
        "formattedDate": "December 20, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "riverpod",
            "permalink": "/blog/tags/riverpod"
          },
          {
            "label": "notifier",
            "permalink": "/blog/tags/notifier"
          },
          {
            "label": "dart 생성자",
            "permalink": "/blog/tags/dart-생성자"
          }
        ],
        "readingTime": 1.245,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-3",
          "title": "Flutter TIL - 3",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "riverpod",
            "notifier",
            "dart 생성자"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 4",
          "permalink": "/blog/flutter-til-4"
        },
        "nextItem": {
          "title": "Flutter TIL - 2",
          "permalink": "/blog/flutter-til-2"
        }
      },
      "content": "---\r\n\r\n## NotifierProvider의 notifier 메소드\r\n---\r\n\r\n```dart\r\nfinal cartProvider = NotifierProvider<RiverpodCart, List<Product>>(() {\r\n  return RiverpodCart();\r\n});\r\n```\r\n\r\n플러터는 위처럼 provider를 위젯트리에 따로 등록하지 않고 변수로 선언해서 사용한다.\r\n\r\n```dart\r\nreturn ProductTile(\r\n  product: product,\r\n  isInCart: ref.watch(cartProvider).contains(product),\r\n  onPressed: ref.read(cartProvider.notifier).onProductPressed,\r\n);\r\n```\r\n\r\n신기한 것이 있었다. 이렇게 전역변수로 선언한 것을 watch하고 read하는 것은 이해를 했는데 갑자기 `.notifier`.. 이건 뭐지\r\n\r\n실험해보고 찾아보니 `.notifier`를 붙이면 해당 provider의 class로 접근해서 그 class의 메소드 등을 사용할 수 있다는 것.\r\n\r\n즉 위에서 cartProvider의 `NotifierProvider<RiverpodCart, List<Product>>` 중 앞 부분인 `RiverpodCart`에 접근하는 느낌이다.\r\n\r\n`.notifier`를 붙이지 않으면 이 provider의 상태로 접근하는 것이다.\r\n\r\n즉 `List<Product>`에 접근한다. 그래서 contians 메소드를 사용할 수 있었다.\r\n\r\n## dart 생성자\r\n\r\n---\r\n\r\n### named parameter\r\n\r\n생성자 안에 `{}` 중괄호로 파라미터를 묶으면 named parameter 가능\r\n\r\nnamed parameter하면 required 할 수도 있다."
    },
    {
      "id": "flutter-til-2",
      "metadata": {
        "permalink": "/blog/flutter-til-2",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-19-til2/index.md",
        "source": "@site/blog/2023-12-19-til2/index.md",
        "title": "Flutter TIL - 2",
        "description": "---",
        "date": "2023-12-19T00:00:00.000Z",
        "formattedDate": "December 19, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "const",
            "permalink": "/blog/tags/const"
          },
          {
            "label": "provider",
            "permalink": "/blog/tags/provider"
          },
          {
            "label": "riverpod",
            "permalink": "/blog/tags/riverpod"
          }
        ],
        "readingTime": 6.495,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-2",
          "title": "Flutter TIL - 2",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "const",
            "provider",
            "riverpod"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 3",
          "permalink": "/blog/flutter-til-3"
        },
        "nextItem": {
          "title": "Flutter TIL - 1",
          "permalink": "/blog/flutter-til-1"
        }
      },
      "content": "---\r\n\r\n## const에 대해\r\n---\r\n\r\nclass에서 생성자를 `const`로 만들지 않았을 때\r\n\r\n```dart\r\nclass Product {\r\n  final int id;\r\n  final String name;\r\n  final String desc;\r\n  final String price;\r\n  final String imageUrl;\r\n\r\n  Product({\r\n    required this.id,\r\n    required this.name,\r\n    required this.desc,\r\n    required this.price,\r\n    required this.imageUrl,\r\n  });\r\n}\r\n```\r\n\r\n위처럼 만들면 아래 코드는 에러난다.\r\n\r\n```dart\r\nconst List<Product> storeProductList = [];\r\n```\r\n\r\n생성자 Product에 `const`를 붙여주면 해결할 수 있다.\r\n\r\n## context.read에 대해\r\n\r\n---\r\n\r\n```dart\r\nvoid main() {\r\n  runApp(\r\n    MultiProvider(\r\n      providers: [\r\n        ChangeNotifierProvider(\r\n          create: (context) => MyCart(),\r\n        ),\r\n        ChangeNotifierProvider(\r\n          create: (context) => MyBadge(myCart: context.read()),\r\n        ),\r\n      ],\r\n      child: MaterialApp(\r\n        home: MyApp(),\r\n      ),\r\n    ),\r\n  );\r\n}\r\n```\r\n\r\n코드 상황이 위와 같을 때 어떻게 MyCart의 정보를 `contex.read()`로 가져오나 의문이 있었다.\r\n\r\n본론부터 말하면\r\n\r\n```dart\r\n        ChangeNotifierProvider(\r\n          create: (context) => MyBadge(myCart: context.read<MyCart>()),\r\n        ),\r\n```\r\n\r\n위와 같이 사용하면 헷갈릴 일이 없고 가져올 수 있는 이유는 `ChangeNotifierProvider`를 통해서 `MyCart`를 위젯 트리 상 등록 했기에 바로 가져와지는 것이다. 만약 중간에 `MyStore` 같은 다른 위젯이 있었다면 `MyCart`는 저런식으로 가져오지 못한다.\r\n\r\n## List의 값에 const에 대해\r\n\r\n---\r\n\r\n```dart\r\nList<Product> cartProductList = const [];\r\n```\r\n\r\n리스트의 불변을 보장해주기 위해 []앞에 `const` 키워드를 붙일 수 있다. `List<Product>` 앞에 붙이는 것과는 다르다. 리스트를 바꿀 수 있지만(요소 말고) 리스트에 직접적인 값을추가하거나 삭제 수정은 못한다.\r\n\r\n삭제를 원한다면 where를 사용할 수 있다.\r\n\r\n```dart\r\nlist.where((p)=>p!= product).toList();\r\n```\r\n\r\n위처럼 작성하면 list를 돌면서 돌고 있는 값이 p인데 product와 비교하면서 product는 빼고 다시 리스트를 만드는 코드이다.\r\n\r\n추가를 원한다면\r\n\r\n```dart\r\n[...list,product]\r\n```\r\n\r\n아래처럼 간단하게 `...`연산자를 사용할 수 있다.\r\n\r\n## dart 자동 매개변수..?\r\n\r\n---\r\n\r\n```dart\r\n  void onProductPressed(Product product) {\r\n    if (cartProductList.contains(product)) {\r\n      cartProductList = cartProductList.where((p) => p != product).toList();\r\n    } else {\r\n      cartProductList = [...cartProductList, product];\r\n    }\r\n    notifyListeners();\r\n  }\r\n```\r\n\r\n이렇게 매개변수가 필요한 함수로 구현돼있는데\r\n\r\n```dart\r\n      return ProductTile(\r\n        product: product,\r\n        isInCart: providerCart.cartProductList.contains(product),\r\n        onPressed: providerCart.onProductPressed,\r\n      );\r\n```\r\n\r\n이렇게 사용하길래 깜짝 놀랐다. 뭔가 싶었는데 ProductTile class에 비밀이 있었다.\r\n\r\n```dart\r\n  final Product product;\r\n  final bool isInCart;\r\n  final void Function(Product product) onPressed;\r\n```\r\n\r\n이렇게 onPressed가 구현돼있으면 product를 넣지 않아도 알아서 넣어준다고..\r\n\r\nproduct를 넣지 않았는데 어떻게 아냐구요? ProductTile 위젯을 만들 때 product값을 전달하기 때문에 인지할 수 있다고 하네요 !\r\n\r\n정리하자면 특정 위젯에 a라는 값을 통해서 구현하고 그 a라는 값을 매개변수로 사용하는 함수가 있을 때 다른 함수도 그 a라는 값을 필요로 한다면 사용하지 않는다.. 라는 것입니다. 근데 100% 이해를 못했다. 마음에 담아두자.\r\n\r\n## context.read() 2\r\n\r\n---\r\n\r\n한 가지를 더 이해해 버렸다.\r\n\r\n위젯 트리 상에 등록해서 context로 가져올 수 있다면\r\n\r\n```dart\r\ncontext.read<ProviderCart>().onProductPressed\r\n```\r\n\r\n위 처럼 ProviderCart의 함수를 가져올 수 있다.\r\n\r\n## context.select()\r\n\r\n---\r\n\r\n이거 좀 이상하긴 하다. 그래서 이제 완벽히 이해했다.\r\n\r\n`context.watch()` : Provider의 모든 상태를 구독한다.\r\n\r\n`context.select()`: Provider의 특정 상태를 구독한다.\r\n\r\n```dart\r\nfinal count = context.select<Counter,int>((counter) => counter.count);\r\n```\r\n\r\n위 처럼 사용하기 때문에 select는 특정 상태 구독 가능\r\n\r\n`context.read()`: 구독안하고 현재 상태 그냥 가져오기\r\n\r\n드디어 context 3형제는 이해한듯\r\n\r\n## Riverpod\r\n\r\n---\r\n\r\nprovider 만든 사람이 만든거라고 해서 provider랑 비슷할 줄 알았는데 다르다.\r\n\r\nprovider 등록을 MultiProvider에 등록하는 것이 아닌 그냥 전역 변수로 등록한다. 별도 변수에 할당하기 때문에 같은 Provider를 다른 변수에 할당할 수 있다. 그리고 BuildContex를 사용하지 않고 별도의 WidgetRef라는 것을 사용한다.\r\n\r\n:::tip 변경점 정리\r\n\r\n1. provider를 전역 변수로 선언해서 사용\r\n2. BuildContext 대신 WidgetRef 사용\r\n   :::\r\n\r\n나머지는 차차 알아가보는걸로\r\n\r\n`StatelessWidget`은 `ConsumerWidget`으로 바꿔야한다.\r\n그리고 `build()`메소드 파라미터에 `WidgetRef ref`를 추가해야 ref사용할 수 있다.\r\n\r\n`StatefulWidget`은 `ConsumerStatefulWidget`으로 바꿔야 한다.\r\n\r\n바꾸기 싫으면 `Consumer` 위젯으로 감싸서 사용할 수 있다.\r\n\r\n### provider 종류\r\n\r\n1. `StateProvider` : 별로 클래스 선언 없이 가볍게 사용할 수 있다.\r\n\r\n2. `NotifierProvider` : 클래스를 만들어서 사용할 수 있습니다.\r\n\r\n3. `Provider` : 기존 Provider의 Provider와 같음 즉 상태가 없는 Provider들\r\n\r\n### 잡기술\r\n\r\n1. `AutoDispose` : `NotifierProvider`뒤에 `.autoDispose`를 붙이고 `Notifier` extends한 것을 `AutoDisposeNotifier`로 수정하면 됩니다. 자동으로 dispose 해줍니다.\r\n\r\n2. `family` : `NotifierProvider`뒤에 `family`를 추가해서 사용하면 되느데 매개변수 타입을 추가해주면 `build()`에 매개변수 추가해서 사용할 수 있습니다.\r\n\r\n3. `AutoDisposeFamilyNotifier` : 1,2번을 합친 것.\r\n\r\n## Error: Unable to find git in your PATH.\r\n\r\n---\r\n\r\n간혹 flutter를 처음할 때 아래와 같은 에러가 괴롭힌다.\r\n\r\n```bash\r\nError: Unable to find git in your PATH.\r\n```\r\n\r\n```bash\r\ngit config --global --add safe.directory '*'\r\n```\r\n\r\n위 명령어로 해결할 수 있음 저장소 권한 문제인 것같다. 관리자 powershell은 flutter 됐었음"
    },
    {
      "id": "flutter-til-1",
      "metadata": {
        "permalink": "/blog/flutter-til-1",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-16-til1/index.md",
        "source": "@site/blog/2023-12-16-til1/index.md",
        "title": "Flutter TIL - 1",
        "description": "---",
        "date": "2023-12-16T00:00:00.000Z",
        "formattedDate": "December 16, 2023",
        "tags": [
          {
            "label": "TIL",
            "permalink": "/blog/tags/til"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "Bloc",
            "permalink": "/blog/tags/bloc"
          }
        ],
        "readingTime": 2.46,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "flutter-til-1",
          "title": "Flutter TIL - 1",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "TIL",
            "플러터",
            "flutter",
            "Bloc"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 2",
          "permalink": "/blog/flutter-til-2"
        },
        "nextItem": {
          "title": "MVVM 아키텍처",
          "permalink": "/blog/mvvm"
        }
      },
      "content": "---\r\n\r\n일단 vs code 확장은 `bloc`, `dart data class generator`, `dart-import`, `pubspec assist`\r\n\r\n`dart data class generator`가 있으면 코드 자동 생성을 편하게 해준다. (copyWith, constructor 등.. )\r\n\r\n`pubspec assist`가 있으면 패키지를 쉽게 넣을 수 있음\r\n\r\n## Bloc에 대해서\r\n\r\n---\r\n\r\n영상을 보며 따라하면서 저번주에 KOSTA에서 배운 Bloc 사용법에 대해 익히고 있었다.\r\n\r\n영상은 다른 방식이라 헷갈렸는데 VS Code의 Bloc extension을 사용하여 New Bloc을 해가지구 Bloc을 만들었다.\r\n\r\n3개의 파일이 나온다. `bloc`,`event`,`state`\r\n\r\n### state\r\n\r\n```dart\r\nclass TasksState extends Equatable {\r\n  const TasksState({\r\n    this.allTasks = const <Task>[],\r\n  });\r\n\r\n  final List<Task> allTasks;\r\n\r\n  @override\r\n  List<Object> get props => [allTasks];\r\n}\r\n```\r\n\r\n현재 state에는 `List<Task>` 타입의 allTasks라는 상태가 하나 있다.\r\n\r\n여러 개 추가하면 여러 개 되는듯?\r\n\r\n### event\r\n\r\n```dart\r\nsealed class TasksEvent extends Equatable {\r\n  const TasksEvent();\r\n\r\n  @override\r\n  List<Object> get props => [];\r\n}\r\n\r\nclass AddTask extends TasksEvent {\r\n  final Task task;\r\n  const AddTask({\r\n    required this.task,\r\n  });\r\n\r\n  @override\r\n  List<Object> get props => [task];\r\n}\r\n\r\nclass UpdateTask extends TasksEvent {\r\n  final Task task;\r\n  const UpdateTask({\r\n    required this.task,\r\n  });\r\n\r\n  @override\r\n  List<Object> get props => [task];\r\n}\r\n\r\nclass DeleteTask extends TasksEvent {\r\n  final Task task;\r\n  const DeleteTask({\r\n    required this.task,\r\n  });\r\n\r\n  @override\r\n  List<Object> get props => [task];\r\n}\r\n\r\n```\r\n\r\n이렇게 서비스들 만들 수 있다. 현재 전부 구현된건 아닌.. 거같은데 일단 이따 수정\r\n\r\n### bloc\r\n\r\n하다가 깨달았다.\r\n\r\n```dart\r\nclass TasksBloc extends Bloc<TasksEvent, TasksState> {\r\n  TasksBloc() : super(const TasksState()) {\r\n    on<AddTask>(_onAddTask);\r\n  }\r\n\r\n  void _onAddTask(AddTask event, emit) {\r\n    emit(TasksState(\r\n      allTasks: [...state.allTasks, event.task],\r\n    ));\r\n  }\r\n}\r\n```\r\n\r\nBloc을 extends 할 때 `Bloc<event, state>`로 하라고 배웠다. 근데 할 때 state를 `int`나 `bool`같은 타입으로만 지정해줘서 그냥 state로 사용하면 됐었는데 class로 state 타입 지정해주니 state.allTasks로 해야 하더라..\r\n\r\n### 깨달음\r\n\r\nbloc에서 큰 실수가 있었다. 위코드 처럼 작성하면 되는데 코드 수를 줄여보겠다고\r\n\r\n```dart\r\n  void _onAddTask(AddTask event, emit) {\r\n    emit(\r\n      [...state.allTasks, event.task],\r\n    );\r\n  }\r\n```\r\n\r\n위처럼 작성했다가 작동을 안해서 살짝 어지러웠다.\r\n\r\nBloc이 `Bloc<TasksEvent,TasksState>`이니 TasksState type에 맞춰줘야 하나보다."
    },
    {
      "id": "mvvm",
      "metadata": {
        "permalink": "/blog/mvvm",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-15-mvvm/index.md",
        "source": "@site/blog/2023-12-15-mvvm/index.md",
        "title": "MVVM 아키텍처",
        "description": "---",
        "date": "2023-12-15T00:00:00.000Z",
        "formattedDate": "December 15, 2023",
        "tags": [
          {
            "label": "KOSTA",
            "permalink": "/blog/tags/kosta"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "mvvm",
            "permalink": "/blog/tags/mvvm"
          }
        ],
        "readingTime": 1.42,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "mvvm",
          "title": "MVVM 아키텍처",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "KOSTA",
            "플러터",
            "flutter",
            "mvvm"
          ]
        },
        "prevItem": {
          "title": "Flutter TIL - 1",
          "permalink": "/blog/flutter-til-1"
        },
        "nextItem": {
          "title": "테스트 코드",
          "permalink": "/blog/test code"
        }
      },
      "content": "---\r\n\r\n## 관심사 분리\r\n---\r\n\r\n모듈 별 경계를 나누고 모듈간 약속을 정하는 것 like a 전기 콘센트와 플러그의 관계라고 한다.\r\n\r\n\r\n## MVVM 이론\r\n---\r\n\r\n`View`와 `ViewModel` 그리고 `Model`을 나누어 View를 쉽게 변경할 수 있는 목적을 갖고 있는 아키텍처 패턴\r\n\r\n:::tip 역할\r\n`View` : UI  \r\n`ViewModel`: View 상태 및 로직 담당  \r\n`Model`: 비지니스 로직과 데이터 입출력 담당\r\n:::\r\n\r\n핵심은 `데이터 바인딩`이다.\r\n\r\n`데이터 바인딩`이란 간단히 말하면 ViewModel과 View가 서로를 의존하지 않는 것 `Provider` 패키지를 사용해서 데이터 바인딩 이용한다는데 나는 Bloc를 사용해서 하고 싶다.. 당장은 Provider로 구현해보기\r\n\r\n페이지 마다 하나의 ViewModel이 있어야 하고 ViewModel은 View의 상태와 로직을 관리한다.\r\n\r\nModel은 `Service`, `Model`, `Repository`가 있는데 `Service`는 전역 상태와 비지니스 로직을 관리하고 `Model`은 데이터 `Repository`는 데이터 요청 로직을 담당한다.\r\n\r\n걍 뭔가 어려움 많이 연습해봐야겠다."
    },
    {
      "id": "test code",
      "metadata": {
        "permalink": "/blog/test code",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-12-15-testcode/index.md",
        "source": "@site/blog/2023-12-15-testcode/index.md",
        "title": "테스트 코드",
        "description": "---",
        "date": "2023-12-15T00:00:00.000Z",
        "formattedDate": "December 15, 2023",
        "tags": [
          {
            "label": "KOSTA",
            "permalink": "/blog/tags/kosta"
          },
          {
            "label": "플러터",
            "permalink": "/blog/tags/플러터"
          },
          {
            "label": "flutter",
            "permalink": "/blog/tags/flutter"
          },
          {
            "label": "테스트 코드",
            "permalink": "/blog/tags/테스트-코드"
          },
          {
            "label": "test code",
            "permalink": "/blog/tags/test-code"
          }
        ],
        "readingTime": 4.005,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "test code",
          "title": "테스트 코드",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "KOSTA",
            "플러터",
            "flutter",
            "테스트 코드",
            "test code"
          ]
        },
        "prevItem": {
          "title": "MVVM 아키텍처",
          "permalink": "/blog/mvvm"
        },
        "nextItem": {
          "title": "와이어샤크",
          "permalink": "/blog/kosta3"
        }
      },
      "content": "---\r\n\r\n[테스트 코드 작성 요령](https://github.com/flutter/flutter/tree/master/packages/flutter/test/material)\r\n\r\n테스트 코드를 작성하면 기능들의 의존성도 확인할 수 있고 테스트할 기능이 많아질 수록 자동화 해놓면 좋다.\r\n\r\n:::tip 테스트 종류\r\n`단위 테스트 ( Unit Test )`: 특정 함수 및 클래스 테스트  \r\n`위젯 테스트 ( Widget Test )`: 단일 위젯 테스트  \r\n`통합 테스트 ( Integration Test )`: 앱의 전체적인 테스트 동작\r\n:::\r\n\r\n## 단위 테스트\r\n---\r\n\r\n내장 테스트로 테스트를 진행할 수 있습니다.\r\n\r\n테스트 파일은 `파일이름_test.dart`여야 한다. 즉 `_test.dart`로 끝나야 함\r\n\r\n:::tip 테스트 관련 함수\r\n`test()`: 테스트 시작\r\n`expect()`: 값 검증  \r\n`group()`: 테스트 그룹 만들기  \r\n`setUp()`: 테스트 시작 전 실행하는 함수(계속 테스트 시작할 때마다 실행)  \r\n`setUpAll()`: 최초 한 번만 실행  \r\n`tearDown()`: 테스트 후 실행  \r\n`tearDownAll()`: 테스트 종료 후 마지막 한 번 실행\r\n:::\r\n\r\n테스트를 하다보면 왜하나 싶을 수 있는데 변경에 대처하기 위해서 작성하는 것임. 완전 변한다면 또 의미가 없어지긴하는데 리팩토링 했을 때 검증하는 느낌이려나 아직은 잘 모르겠다.\r\n\r\n\r\n### Mock Object\r\n\r\napi 통신 테스트 같은 경우 외부 변수가 많아서 mock object로 한다.\r\n\r\n왜냐하면 실제 요청 응답은 변수가 많아서... 재현이 어렵다. 그리고 실제로 서버 응답 실패 테스트 같은 경우도 쉽지 않다. mock object를 사용하면 쉽게 할 수 있다.\r\n\r\nmockito랑 build_runner를 사용한다고 한다.\r\n\r\nmockito로 어노테이션 달고 build_runner로 코드 생성하는 거임\r\n\r\n\r\n### DI ( Dependency Injection )\r\n\r\ndi를 하는데 생성자를 통해 외부 코드를 받는다인 간단한 개념이라고 한다.\r\n\r\n  \r\n  \r\n\r\n## 위젯 테스트\r\n---\r\n\r\n상호작용, 생김새, 상태 확인을 테스트 한다고 한다.\r\n\r\n\r\n:::tip 위젯 테스트\r\n`testWidgets()`: 테스트 진행  \r\n`pump()`: 화면 갱신  \r\n`find.text()`: 특정 테스트 검색  \r\n`find.byType()`: 특정 클래스의 타입과 일치하는 위젯 검색  \r\n`tester.widget()`: 특정 타입의 위젯 가져옴  \r\n`tester.element()`: 특정 위젯의 BuildContext 가져옴\r\n:::\r\n\r\n[golden test](https://api.flutter.dev/flutter/flutter_test/matchesGoldenFile.html)도 있다.\r\n\r\ngolden test는 이미지 픽셀 비교하는 테스트다 즉 시각적 모습을 테스트할 수 있다.\r\n\r\n\r\n```bash\r\nflutter test --update-goldens\r\n```\r\n\r\n이걸로 골든테스트 정답 생성해줌 신기하넹.\r\n\r\n\r\n## 통합 테스트\r\n---\r\n\r\nGUI테스트 EndToEnd라고 합니다.\r\n\r\n실제 에뮬레이터를 통해서 테스트를 하게 된다.\r\n\r\n`integration_test`를 추가해야 한다고 합니다.\r\n\r\n```bash\r\n\r\n  integration_test:\r\n    sdk: flutter\r\n```\r\n\r\ndev_dependecies에 붙여넣어주면 된다.\r\n\r\n\r\nintegration_test라는 폴더를 root에 만들어주고 하면 된다.\r\n아주 신기하다.\r\n\r\n## 테스트 커버리지\r\n---\r\n\r\n[플러터 커버리지](https://marketplace.visualstudio.com/items?itemName=Flutterando.flutter-coverage)\r\n\r\n테스트 코드 기반으로 커버리지 측정을 한다.\r\n\r\n[커버리지 거터스](https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters)\r\n\r\n이거는 특정 파일에서 좌측 하단 watch를 눌러보면 어디가 테스트가 안됐는지와 커버리지 % 알려준다.\r\n\r\n\r\nhydrated bloc을 사용해보거나 다른 서드파티들 검색해서 찾아보자"
    },
    {
      "id": "kosta3",
      "metadata": {
        "permalink": "/blog/kosta3",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-11-29-KOSTA3/index.md",
        "source": "@site/blog/2023-11-29-KOSTA3/index.md",
        "title": "와이어샤크",
        "description": "---",
        "date": "2023-11-29T00:00:00.000Z",
        "formattedDate": "November 29, 2023",
        "tags": [
          {
            "label": "KOSTA",
            "permalink": "/blog/tags/kosta"
          },
          {
            "label": "와이어샤크",
            "permalink": "/blog/tags/와이어샤크"
          }
        ],
        "readingTime": 2.065,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "kosta3",
          "title": "와이어샤크",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "KOSTA",
            "와이어샤크"
          ]
        },
        "prevItem": {
          "title": "테스트 코드",
          "permalink": "/blog/test code"
        },
        "nextItem": {
          "title": "와이어샤크",
          "permalink": "/blog/kosta-2"
        }
      },
      "content": "---\r\n\r\n### 이름 풀이 기능 참조 파일\r\n\r\n- mac address 사용자 정의 C:\\Program Files\\Wireshark\\ethers\r\n- port number 정보 C:\\Program Files\\Wireshark\\services\r\n- 호스트 이름 정보 C:\\Program Files\\Wireshark\\hosts\r\n\r\n### 와이어샤크는 포트번호가 인식되지 않을때 data로 해석됩니다. 비표준 포트 번호를 사용하는 FTP 서비스를 수동으로 분석기를 설정하는 메뉴는 어디인가요?\r\n\r\nAnalyze>Decode as\r\n\r\n### WLAN 프로파일을 생성시 환경설정 저장 경로는 어디인가요?\r\n\r\nC:\\Users\\user1\\AppData\\Roaming\\Wireshark\\Profile\r\n\r\n### 원격지 트래픽 캡쳐를 수행하려고 합니다. 캡쳐하고자 하는 컴퓨터에 winpcap을 설치한 후 원격지에 실행해야하는 데몬 실행파일은 무엇인가요?\r\n\r\nrpcapd.exe\r\n\r\n### 기존 추적파일에는 적용할 수 없고 실시간 캡쳐하는 작업에만 적용되는 필터로 TCPDUMP 구문의 BPF형식을 따르는 필터는 무엇인가요?\r\n\r\n캡쳐필터\r\n\r\n### 실시간 캡쳐 필터구문을 작성하세요. \r\n\r\n- http와 dns 패킷을 동시 캡쳐 `tcp port 80 or udp port 53`\r\n- 목적지 IP주소가 10.10.10.10 이면서 telnet 패킷만 캡쳐 `ip dst 10.10.10.10 and tcp port 23`\r\n- icmp ttl 에러만 캡쳐 `icmp[0]=11 and icmp[1]=0`\r\n\r\n### 전역환경설정 위치에 존재하는 파일로 업그레이드시 복사본을 만들어야 하는 파일을 쓰세요.\r\n\r\n- 실시간 캡쳐 필터 cfilters\r\n- 디스플레이 필터 dfilters\r\n- 컬러링 필터 colorfilter\r\n\r\n### 실시간 캡쳐시 파일집합으로 최근 10개 파일만 생성을 유지할 수 있는 설정은 무엇인가요?\r\n\r\n링버퍼"
    },
    {
      "id": "kosta-2",
      "metadata": {
        "permalink": "/blog/kosta-2",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-11-28-KOSTA2/index.md",
        "source": "@site/blog/2023-11-28-KOSTA2/index.md",
        "title": "와이어샤크",
        "description": "---",
        "date": "2023-11-28T00:00:00.000Z",
        "formattedDate": "November 28, 2023",
        "tags": [
          {
            "label": "KOSTA",
            "permalink": "/blog/tags/kosta"
          },
          {
            "label": "와이어샤크",
            "permalink": "/blog/tags/와이어샤크"
          }
        ],
        "readingTime": 3.365,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "kosta-2",
          "title": "와이어샤크",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "KOSTA",
            "와이어샤크"
          ]
        },
        "prevItem": {
          "title": "와이어샤크",
          "permalink": "/blog/kosta3"
        },
        "nextItem": {
          "title": "와이어샤크",
          "permalink": "/blog/kosta-1"
        }
      },
      "content": "---\r\n\r\n## 문제\r\n---\r\n\r\n### PDU\r\n\r\n- L1> bits\r\n- L2> frame\r\n- L3> packet\r\n- L4> segement\r\n- L5~L7> message, data stream\r\n\r\n### 캐시 확인 및 삭제\r\n\r\n- MAC\r\n\r\n```bash title='추가'\r\narp -a\r\n```\r\n\r\n```bash title='삭제'\r\narp -d\r\n```\r\n\r\n- DNS\r\n\r\n```bash title='추가'\r\nipconfig/displaydns\r\n```\r\n\r\n```bash title='삭제'\r\nipconfig/flushdns\r\n```\r\n\r\n- NetBIOS\r\n\r\n```bash title='추가'\r\nnbtstat -c\r\n```\r\n\r\n```bash title='삭제'\r\nnbtstat -R\r\n```\r\n\r\n### OSI \r\n\r\nMAC주소 포함 : L2 - datalink layer\r\nIP주소 포함 : L3 - network layer\r\n\r\n### 기본 최대 크기\r\nEthernet Frame : 1518 Byte\r\nMTU : 1500 byte 크기변경 가능\r\nMSS : 1460 byte\r\n\r\n\r\n## 목적지 IP주소에 대한 MAC주소를 찾아오는 프로토콜\r\n\r\narp\r\n\r\n### TCP 헤더에서 Flag 6개\r\n\r\nsyn,ack,fin,rst,psh,urg\r\n\r\n###  TCP/IP에서 연결상태를 확인하고 에러메세지를 전달하는 프로토콜\r\n\r\nicmp\r\n\r\n### 스위치 기본 기능\r\n\r\nflooding, learning, fowarding, filtering\r\n\r\n\r\n\r\n## 와이어샤크\r\n---\r\n\r\n### 병합\r\n\r\n와이어샤크에 일시중지 기능은 없다 정지 이후 다시 캡쳐해서 병합하는 방법밖에 없다.\r\n\r\n병합은 파일 > 병합에서 가능\r\n\r\n와이어샤크는 두개의 파일을 동시에 열 수 없어서 병합을 사용한다.\r\n\r\n병합에는 3가지 옵션이 있는데 기본값은 시간 기준으로 병합하는 것이고 전에 이어붙이기 후에 이어붙이기가 있습니다.\r\n\r\n### 캡처 파일\r\n\r\n열기 폴더 버튼으로 파일을 연다면 캡처 시간과 사이즈 등을 추가로 확인할 수 있다.\r\n\r\n\r\n### 새로고침 버튼\r\n\r\n와이어샤크는 time 칼럼의 작동방식이 지연 시간 작동방식을 채택한다.\r\n\r\n\r\n그래서 1번 패킷이 0.00초이고 그다음 부터는 1번 패킷 이후 캡쳐된 지연 시간이다.\r\n\r\n그런데 10번 패킷을 0초로 설정하는 방법이 있는데 `시간 참조 설정`을 하면 할 수 있다.\r\n\r\n`시간 참조 설정`은 하나에만 할 수 있는 것이 아닌데 그래서 나중에 풀어주려고 하면 너무 어렵다.\r\n\r\n이 때 `파일 다시 불러오기` 버튼이 이를 모두 해제해준다.\r\n\r\n그래서 `파일 다시 불러오기` 버튼을 자주 사용한다고 한다.\r\n\r\n\r\n### 이름 해석\r\n\r\n보기 > 이름해석 > 네트워크 주소 해석을 키면 패킷의 IPv4에서 dns 주소로 확인할 수 있다.\r\n\r\n근데 이러면 쓸데없는 UDP 패킷이 생기기 때문에 실시간 패킷을 캡쳐할 때 이름 해석을 해제하고 하는 것이 좋다.\r\n\r\n보기 > 이름해석 > 전송주소 해석을 키면 포트 번호에 이름을 붙여줌\r\n\r\n\r\n:::tip 이름 해석 커스텀\r\n`MAC addr`  c:\\program files\\wireshark\\ethers\r\n`IP addr`   c:\\program files\\wireshark\\hosts\r\n`port name` c:\\program files\\wireshark\\services\r\n:::"
    },
    {
      "id": "kosta-1",
      "metadata": {
        "permalink": "/blog/kosta-1",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-11-27-KOSTA1/index.md",
        "source": "@site/blog/2023-11-27-KOSTA1/index.md",
        "title": "와이어샤크",
        "description": "---",
        "date": "2023-11-27T00:00:00.000Z",
        "formattedDate": "November 27, 2023",
        "tags": [
          {
            "label": "KOSTA",
            "permalink": "/blog/tags/kosta"
          },
          {
            "label": "와이어샤크",
            "permalink": "/blog/tags/와이어샤크"
          }
        ],
        "readingTime": 5.6,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "kosta-1",
          "title": "와이어샤크",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "KOSTA",
            "와이어샤크"
          ]
        },
        "prevItem": {
          "title": "와이어샤크",
          "permalink": "/blog/kosta-2"
        },
        "nextItem": {
          "title": "PKI 개념",
          "permalink": "/blog/PKI"
        }
      },
      "content": "---\r\n\r\n## 와이어샤크 설치\r\n---\r\n\r\n[이곳](https://www.wireshark.org/)에서 진행할 수 있습니다.\r\n\r\n## 컴퓨터 네트워크\r\n---\r\n\r\n데이터 통신은 MAC주소가 꼭 필요함. 이걸 논리적으로 바꾼 주소가 IP주소\r\n\r\n### 물리주소 확인\r\n\r\n```bash\r\narp -a\r\n```\r\n\r\n캐시 데이터다. 5분뒤에 지어짐 근데 지우려면\r\n\r\n```bash\r\napr -d\r\n```\r\n\r\n캐시가 남는경우는 내가 상대방과 연결을 할 때도 있지만 상대방이 나와 연결할 때도 캐시가 남음.\r\n\r\n그래서 패킷 분석할 때 캐시를 지워야 한다.\r\n\r\n\r\n### dns가 알려준 ip 캐시 정보 확인\r\n---\r\n\r\n```bash\r\nipconfig/displaydns\r\n```\r\n\r\n지우기\r\n\r\n```bash\r\nipconfig/flushdns\r\n```\r\n\r\n### 컴퓨터 이름으로 통신\r\n---\r\n\r\n```bash\r\nnbtstat -n\r\n```\r\n\r\n캐시 확인\r\n\r\n```bash\r\nnbtstat -c\r\n```\r\n\r\n캐시 삭제\r\n\r\n```bash\r\nnbtstat -R\r\n```\r\n\r\n분석할 때 arp, dns, nbtstat 캐시 지워주고 하는게 좋다.\r\n\r\n\r\n\r\n### OSI 7 계층\r\n\r\n계층을 통과할 때는 관련 헤더가 추가된다. PDU가 있다.\r\n\r\nPDU는 아래 정리..\r\n\r\n`Presentation` : Message\r\n\r\n`Transport` : Segment\r\n\r\n`Network` : packet\r\n\r\n`Datalink` : frame\r\n\r\n---\r\n\r\n`Application` : 통신 software\r\n\r\n`Presentation` : 데이터 포맷 정의 (jpg,png 등)\r\n\r\n`Session` : App 연결 유지 or 해제\r\n\r\n`Transport` : 패킷 분리, 재전송, 에러 검출 (Segment가 전송 최소단위여서)\r\n\r\n`Network` : Segment앞에 논리적 주소(IP)를 추가해서 목적 전달 가능하게 해줌 > Packet\r\n\r\n`Datalink` : 물리 주소를 추가해서 전달(MAC,DLCI) > Frame\r\n\r\n`Pyhsical` : bit를 전기신호로 변환, 전기적, 기능적 특성, 절차적 특성, 기계적 특성에 대한 약속\r\n\r\n\r\n### TCP/IP 4 계층\r\n\r\n`Application` : osi의 application, presentation, session을 합친 계층, http, telnet, dns, dhcp 프로토콜이 있음\r\n\r\n`Transport` : TCP,UDP 프로토콜이 있음\r\n\r\n    + 포트번호를 통해서 Application 어디로 보낼지 담겨있음\r\n\r\n\r\n`Internet` : OSI의 network 계층, ICMP, IP, ARP RARP 있다. \r\n    \r\n    + protocol Number 를 통해서 TCP,UDP.. 등 어디로 넘기지 담겨있음\r\n\r\n`network access` : OSI의 datalink, physical 계층 ethernet2(MAC) \r\n    \r\n    + Type(IPv4, IPv6)이 인터넷 계층 프로토콜 어디로 보낼지 구분해줌 \r\n\r\n![Alt text](image.png)\r\n\r\n\r\n### 포트번호\r\n\r\n`0 ~ 1023` : 잘 알려진 서비스 예약 포트\r\n\r\n`1024 ~ 49151` : 추가 표준 상용 tool 예약 포트\r\n\r\n`49152 ~ 65535` : 개인용 포트\r\n\r\n\r\n:::tip\r\n[도움이 되는 다양한 정보들이 담긴 url 1](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)  \r\n[도움이 되는 다양한 정보들이 담긴 url 2](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)\r\n:::\r\n\r\n\r\n### 네트워크 연결 장치\r\n\r\n1. HUB\r\n\r\n허브는 다 확인해보고 해당 목적지인지 검사하고 아니면 다음 목적지로.. 반복\r\n\r\n2. Switch\r\n\r\n스위치는 목적지 주소가 포함되어 있어서 해당 목적지에만 방문 근데 FFFF가 목적지 주소이면 브로드캐스트 인데 모든 스위치에 전달(Flooding)하기 때문에 네트워크 부하가 옴 > 차단의 필요성이 있다.\r\n\r\n:::tip 스위치 동작\r\n1. Flooding\r\n\r\n들어온 포트를 제외하고 모든 포트에 뿌림\r\n\r\n2. Learning\r\n\r\n맥주소를 학습해서 맥 테이블에 작성\r\n\r\n3. Forwarding\r\n\r\n목적지 맥주소에 그대로 프레임 보내는 것\r\n\r\n4. Filtering\r\n\r\n목적지 주소를 알고 있을 때 프레임 전송을 막는 것\r\n\r\n:::\r\n\r\n\r\n3. Router\r\n\r\n라우터는 네트워크 별로 전송 차단할 수 있음. 브로드캐스트로 인한 네트워크 부하 방지\r\n\r\n### TCP와 UDP\r\n\r\n`TCP` : 헤더(20 ~ 60byte)\r\n\r\nA >> 확인신호 >> B\r\n\r\nB >> 응답 >> A\r\n\r\nA >> 연결 확정 >> B\r\n\r\nA >> 데이터 전달 >> B\r\n\r\nB >> 응답 >> A\r\n\r\n`UDP` : 헤더 (8byte)\r\n\r\nA >> 데이터 전달 >> B\r\n\r\n## wireshark\r\n---\r\n\r\n와이어샤크는 마지막 상태 설정이 저장된다.\r\n\r\n\r\n\r\n캡처 옵션에서 모두 무작위를 끄면 나한테 들어오는 패킷만 확인할 수 있다.\r\n\r\n### 숨김\r\n\r\n캡처 > 옵션 > 인터페이스관리에서 표시를 체크 해제하면 인터페이스를 숨길 수 있다.\r\n\r\n아니면 네트워크 설정에서 어댑터 사용안하면 안보임\r\n\r\n아니면 라이브러리(npcap)가 삭제됐을 수도 있음.\r\n\r\n아니면 가상 인터페이스를 추가하고 재부팅해야 보임\r\n\r\n\r\n### 통계\r\n\r\n필터에 `tcp.stream == 1` 등으로 필터링 후\r\n\r\n통계 > 플로 그래프 > 표시 필터로 제한\r\n\r\n![Alt text](image-1.png)\r\n\r\n\r\n### 스트림 확인\r\n\r\n패킷에 우클릭 > 따라가기 > TCP 스트림 등..\r\n\r\n한 눈에 보인다.\r\n\r\nTCP는 최대 길이가 1514여서 잘려서 분석하기 어려울 수 있는데 한 눈에 확인 가능"
    },
    {
      "id": "PKI",
      "metadata": {
        "permalink": "/blog/PKI",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-10-25-pki/index.md",
        "source": "@site/blog/2023-10-25-pki/index.md",
        "title": "PKI 개념",
        "description": "PKI란 Public Key Infrastructure의 약자로 공개키 암호화와 전자서명을 사용할 수 있게 기반을 마련해둔 것이라고 합니다.",
        "date": "2023-10-25T00:00:00.000Z",
        "formattedDate": "October 25, 2023",
        "tags": [
          {
            "label": "pki",
            "permalink": "/blog/tags/pki"
          }
        ],
        "readingTime": 2.46,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "PKI",
          "title": "PKI 개념",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "pki",
            "PKI"
          ]
        },
        "prevItem": {
          "title": "와이어샤크",
          "permalink": "/blog/kosta-1"
        },
        "nextItem": {
          "title": "Overloading & Overriding",
          "permalink": "/blog/Overloading and Overriding"
        }
      },
      "content": "PKI란 Public Key Infrastructure의 약자로 공개키 암호화와 전자서명을 사용할 수 있게 기반을 마련해둔 것이라고 합니다.\r\n\r\n\r\n신뢰기간이 공개키들을 인증해주면 그 공개키에 대응되는 개인키도 인증되기 때문에 개인키를 갖고 있는 개인이 인증을 받습니다.\r\n\r\n\r\n## 은행에서 공인인증서 인증 과정\r\n---\r\n\r\n은행에서 공인인증서 과정를 인증하는 과정이 있습니다.\r\n\r\n![Alt text](image.png)\r\n\r\n### 생성 과정\r\n\r\n1. 먼저 개인이 공인 인증서 발급을 CA에 요청합니다.\r\n\r\n2. 그러면 CA에서 개인의 개인키, 공개키를 생성합니다.\r\n\r\n3. 생성한 키들로 디지털 인증서를 발급합니다.\r\n\r\n:::tip 디지털 인증서에 들어가는 것\r\n`발급자 정보`,  `소유자 정보`, `인증서 권한`, `유효기간`, `발급자 전자 서명`, `일련번호`, `소유자 공개키 정보`\r\n:::\r\n\r\n4. 디지털 서명 생성을 생성합니다.\r\n\r\n디지털 서명은 전송할 문서를 인증해주는 도구입니다.\r\n\r\n:::tip 디지털 서명 생성 절차\r\n1. 메시지 or 문서 선택\r\n2. 메시지 or 문서에 해시 함수 적용 > `해시 값`\r\n3. 사용자의 개인키로 `해시 값` 암호화 > `디지털 서명`\r\n:::\r\n\r\n\r\n### 확인 과정\r\n\r\n1. `원본 메시지`와 `디지털 서명`을 받습니다.\r\n\r\n2. 디지털 인증서에서 추출한 공개키로 `디지털 서명`을 복호화합니다. > `해시 값`\r\n\r\n3. `원본 메시지` 해시해보며 복호화한 `해시 값`과 동일한지 확인하여 무결성 검사를 합니다.\r\n\r\n4. 디지털 인증서의 유효기간을 확인합니다.\r\n\r\n그러면 PKI 인증이 됩니다. 여기서 은행과 통신하고 싶다면 메시지 또는 문서가 은행의 인증서가 되겠네요."
    },
    {
      "id": "Overloading and Overriding",
      "metadata": {
        "permalink": "/blog/Overloading and Overriding",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-09-16-over/index.md",
        "source": "@site/blog/2023-09-16-over/index.md",
        "title": "Overloading & Overriding",
        "description": "오버로딩과 오버라이딩에 대해서 알아보겠습니다.",
        "date": "2023-09-16T00:00:00.000Z",
        "formattedDate": "September 16, 2023",
        "tags": [
          {
            "label": "Overriding",
            "permalink": "/blog/tags/overriding"
          },
          {
            "label": "Overloading",
            "permalink": "/blog/tags/overloading"
          },
          {
            "label": "오버로딩",
            "permalink": "/blog/tags/오버로딩"
          },
          {
            "label": "오버라이딩",
            "permalink": "/blog/tags/오버라이딩"
          }
        ],
        "readingTime": 3.87,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "Overloading and Overriding",
          "title": "Overloading & Overriding",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "Overriding",
            "Overloading",
            "오버로딩",
            "오버라이딩"
          ]
        },
        "prevItem": {
          "title": "PKI 개념",
          "permalink": "/blog/PKI"
        },
        "nextItem": {
          "title": "[SOLID] 객체 지향 프로그래밍(OOP) 원칙",
          "permalink": "/blog/design pattern rule"
        }
      },
      "content": "오버로딩과 오버라이딩에 대해서 알아보겠습니다.\r\n\r\n## 오버로딩 (Overloading)\r\n\r\n### 정의\r\n\r\n한 클래스 내에 이미 **사용하려는 이름**과 **같은 이름**을 가진 **`메소드`**가 있어도 매개 변수의 개수와 타입이 다르면 같은 이름을 사용해서 메소드를 재정의 할 수 있다.\r\n\r\n여기서 핵심은 2가지로 정리할 수 있습니다.\r\n\r\n1. 메소드의 이름이 같다.\r\n2. 매개변수의 개수나 타입이 달라야 한다.\r\n3. 리턴값과는 상관 없습니다.\r\n\r\n\r\n### 오버로딩 함수 코드\r\n\r\n```java title='오버로딩 함수'\r\npublic class OverringClass {\r\n    \r\n    // 오버로딩 1번 함수\r\n    public void OverloadMethod(){\r\n        System.out.println(\"============================\");\r\n        System.out.println(\"매개변수 수 : 0개\");\r\n        System.out.println(\"매개변수 타입 : void\");\r\n        System.out.println(\"오버라이딩 1번 함수 입니다.\");\r\n        System.out.println(\"============================\");\r\n    }\r\n\r\n    // 오버로딩 2번 함수\r\n    public int OverloadMethod(int a, int b){\r\n        System.out.println(\"============================\");\r\n        System.out.println(\"매개변수 수 : 2개\");\r\n        System.out.println(\"매개변수 타입 : int\");\r\n        System.out.println(\"오버라이딩 2번 함수 입니다. 덧셈 값을 반환합니다.\");\r\n        System.out.println(\"============================\");\r\n\r\n        return a+b;\r\n    }\r\n\r\n    // 오버로딩 3번 함수\r\n    public int OverloadMethod(int a, int b, int c){\r\n        System.out.println(\"============================\");\r\n        System.out.println(\"매개변수 수 : 3개\");\r\n        System.out.println(\"매개변수 타입 : int\");\r\n        System.out.println(\"오버라이딩 3번 함수 입니다. 곱셈을 반환합니다.\");\r\n        System.out.println(\"============================\");\r\n\r\n        return a*b*c;\r\n    }\r\n\r\n\r\n    // 오버로딩 4번 함수\r\n    public boolean OverloadMethod(String str){\r\n        System.out.println(\"============================\");\r\n        System.out.println(\"매개변수 수 : 1개\");\r\n        System.out.println(\"매개변수 타입 : String\");\r\n        System.out.println(\"오버라이딩 4번 함수 입니다. 이름이 park이면 true를 반환합니다.\");\r\n        System.out.println(\"============================\");\r\n\r\n        if(str.equals(\"park\")){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n위 함수들을 보시면 `OverloadMethod`로 이름들이 같지만 타입과 매개변수의 수가 다른 것들을 보실 수 있습니다. 함수들에 대한 설명은 코드에 작성돼 있으니 참고해주세요~ 😎\r\n\r\n코드를 실행하는 코드와 결과를 확인해보겠습니다.\r\n\r\n``` java title='결과 확인 코드'\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        OverringClass oc = new OverringClass();\r\n        \r\n        // 오버로딩 1번 함수\r\n        oc.OverloadMethod();\r\n\r\n        // 오버로딩 2번 함수\r\n        int a = oc.OverloadMethod(1,2);\r\n        System.out.println(\"오버로딩 2번 함수 반환값 : \"+a);\r\n\r\n        // 오버로딩 3번 함수\r\n        int b = oc.OverloadMethod(4,5,6);\r\n        System.out.println(\"오버로딩 3번 함수 반환값 : \"+b);\r\n\r\n        // 오버로딩 4번 함수\r\n        boolean c = oc.OverloadMethod(\"park\");\r\n        System.out.println(\"오버로딩 4번 함수 반환값 : \"+c);\r\n    }\r\n}\r\n```\r\n\r\n```text title='결과'\r\n============================\r\n매개변수 수 : 0개\r\n매개변수 타입 : void\r\n오버라이딩 1번 함수 입니다.\r\n============================\r\n============================\r\n매개변수 수 : 2개\r\n매개변수 타입 : int\r\n오버라이딩 2번 함수 입니다. 덧셈 값을 반환합니다.\r\n============================\r\n오버로딩 2번 함수 반환값 : 3\r\n============================\r\n매개변수 수 : 3개\r\n매개변수 타입 : int\r\n오버라이딩 3번 함수 입니다. 곱셈을 반환합니다.\r\n============================\r\n오버로딩 3번 함수 반환값 : 120\r\n============================\r\n매개변수 수 : 1개\r\n매개변수 타입 : String\r\n오버라이딩 4번 함수 입니다. 이름이 park이면 true를 반환합니다.\r\n============================\r\n오버로딩 4번 함수 반환값 : true\r\n```"
    },
    {
      "id": "design pattern rule",
      "metadata": {
        "permalink": "/blog/design pattern rule",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-08-29-rule/index.md",
        "source": "@site/blog/2023-08-29-rule/index.md",
        "title": "[SOLID] 객체 지향 프로그래밍(OOP) 원칙",
        "description": "SRP ( 단일 책임의 원칙 : Single Responsibility Principle )",
        "date": "2023-08-29T00:00:00.000Z",
        "formattedDate": "August 29, 2023",
        "tags": [
          {
            "label": "design pattern",
            "permalink": "/blog/tags/design-pattern"
          },
          {
            "label": "rule",
            "permalink": "/blog/tags/rule"
          }
        ],
        "readingTime": 1.925,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "design pattern rule",
          "title": "[SOLID] 객체 지향 프로그래밍(OOP) 원칙",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "design pattern",
            "rule"
          ]
        },
        "prevItem": {
          "title": "Overloading & Overriding",
          "permalink": "/blog/Overloading and Overriding"
        },
        "nextItem": {
          "title": "전략 패턴 - Strategy pattern",
          "permalink": "/blog/strategy pattern"
        }
      },
      "content": "## SRP ( 단일 책임의 원칙 : Single Responsibility Principle )\r\n\r\n## OCP ( 계방-폐쇄의 원칙 : Open Close Principle )\r\n\r\n1. 바뀌는 부분을 캡슐화한다.\r\n    - 변하는(확장되는) 것과 변하지 않을 것을 구분\r\n\r\n2. 상속보다는 구성을 활용한다.\r\n\r\n3. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.\r\n    - 정의한 인터페이스에 의존\r\n\r\n4. 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다.\r\n\r\n5. 클래스는 확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다.\r\n\r\n## LSP ( 리스코프 치환의 원칙 : The LisKov Substitution Principle )\r\n\r\n## ISP ( 인터페이스 분리의 원칙 : Interface Segregation Principle )\r\n\r\n## DIP ( 의존성 역전의 원칙 : Dependency Inversion Principle )\r\n\r\n1. 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.\r\n\r\n2. 고수준 구성 요소가 저수준 구성 요소에 의존하면 안되고 항상 추상화에 의존하게 만들어야 한다.\r\n`고수준 구성 요소` : 다른 `저수준 구성 요소`에 의해 정의되는 행동이 들어있는 구성 요소\r\n\r\n3. 변수에 구상 클래스의 레퍼런스를 저장하지 않는다.\r\n\r\n4. 구상 클래스에서 유도된 클래스를 만들지 않는다.\r\n\r\n5. 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 않는다."
    },
    {
      "id": "strategy pattern",
      "metadata": {
        "permalink": "/blog/strategy pattern",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-08-29-stratgy/index.md",
        "source": "@site/blog/2023-08-29-stratgy/index.md",
        "title": "전략 패턴 - Strategy pattern",
        "description": "정의",
        "date": "2023-08-29T00:00:00.000Z",
        "formattedDate": "August 29, 2023",
        "tags": [
          {
            "label": "design pattern",
            "permalink": "/blog/tags/design-pattern"
          },
          {
            "label": "strategy pattern",
            "permalink": "/blog/tags/strategy-pattern"
          }
        ],
        "readingTime": 1.465,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "strategy pattern",
          "title": "전략 패턴 - Strategy pattern",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "design pattern",
            "strategy pattern"
          ]
        },
        "prevItem": {
          "title": "[SOLID] 객체 지향 프로그래밍(OOP) 원칙",
          "permalink": "/blog/design pattern rule"
        },
        "nextItem": {
          "title": "Welcome",
          "permalink": "/blog/welcome"
        }
      },
      "content": "## 정의\r\n\r\n알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다.\r\n전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.\r\n\r\n## 특징\r\n\r\n- 함수 중 변하는 코드를 class로 구현하여 상속받는 것이 아닌 interface로 구현하여서 Composition하는게 좋다.\r\n\r\n## 예시\r\n\r\n```java title=\"/src/interfaces/FlyBehavior.java\"\r\npublic interface FlyBehavor {\r\n    public void fly();\r\n}\r\n```\r\n위 처럼 나는 행동 인터페이스를 구현하고\r\n\r\n```java title=\"/src/classes/Duck.java\"\r\npublic abstract class Duck {\r\n    FlyBehavor flyBehavor;\r\n\r\n    public void setFlyBehavor(FlyBehavor flyBehavor) {\r\n        this.flyBehavor = flyBehavor;\r\n    }\r\n}\r\n```\r\n추상 클래스에선 interface 선언 및 setter를 구현하고\r\n\r\n```java title=\"/src/classes/FlyNoway ... FlyWithWings.java\"\r\npublic class FlyNoWay implements FlyBehavor {\r\n    @Override\r\n    public void fly() {\r\n        System.out.println(\"I can't fly ! TT\");\r\n    }\r\n}\r\n\r\npublic class FlyRocketPowered implements FlyBehavor {\r\n    @Override\r\n    public void fly() {\r\n        System.out.println(\"ROCKET FLY!!\");\r\n    }\r\n}\r\n\r\npublic class FlyWithWings implements FlyBehavor {\r\n    @Override\r\n    public void fly() {\r\n        System.out.println(\"I can fly!!\");\r\n    }\r\n}\r\n```\r\n\r\n위 코드들처럼 interface를 구현하여서 오버라이딩을 합니다.\r\n\r\n```java title=\"/src/classes/MallardDuck.java\"\r\npublic class MallardDuck extends Duck{\r\n    public MallardDuck(){\r\n        flyBehavor = new FlyWithWings();\r\n    }\r\n}\r\n```\r\n생성자에서 새로 구현한 인터페이스로 생성합니다."
    },
    {
      "id": "welcome",
      "metadata": {
        "permalink": "/blog/welcome",
        "editUrl": "https://github.com/kihyun1998/blogsaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-08-29-welcome/index.md",
        "source": "@site/blog/2023-08-29-welcome/index.md",
        "title": "Welcome",
        "description": "Docusaurus 첫번째 글이다.",
        "date": "2023-08-29T00:00:00.000Z",
        "formattedDate": "August 29, 2023",
        "tags": [
          {
            "label": "docusaurus",
            "permalink": "/blog/tags/docusaurus"
          },
          {
            "label": "first post",
            "permalink": "/blog/tags/first-post"
          }
        ],
        "readingTime": 0.095,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Park Ki Hyun",
            "title": "Deveploper",
            "url": "https://github.com/kihyun1998",
            "imageURL": "https://github.com/kihyun1998.png",
            "key": "kihyun"
          }
        ],
        "frontMatter": {
          "slug": "welcome",
          "title": "Welcome",
          "authors": [
            "kihyun"
          ],
          "tags": [
            "docusaurus",
            "first post"
          ]
        },
        "prevItem": {
          "title": "전략 패턴 - Strategy pattern",
          "permalink": "/blog/strategy pattern"
        }
      },
      "content": "Docusaurus 첫번째 글이다.\r\n\r\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\r\n\r\n귀여운 공룡 인형이 있다."
    }
  ]
}